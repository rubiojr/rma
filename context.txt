context/docs/object-interface.go
---
// Object is the interface that all object types in Risor must implement.
type Object interface {
	// Type of the object.
	Type() Type

	// Inspect returns a string representation of the given object.
	Inspect() string

	// Interface converts the given object to a native Go value.
	Interface() interface{}

	// Returns True if the given object is equal to this object.
	Equals(other Object) Object

	// GetAttr returns the attribute with the given name from this object.
	GetAttr(name string) (Object, bool)

	// SetAttr sets the attribute with the given name on this object.
	SetAttr(name string, value Object) error

	// IsTruthy returns true if the object is considered "truthy".
	IsTruthy() bool

	// RunOperation runs an operation on this object with the given
	// right-hand side object.
	RunOperation(opType op.BinaryOpType, right Object) Object

	// Cost returns the incremental processing cost of this object.
	Cost() int
}


---
context/docs/syntax.mdx
---
# Syntax

The overall idea for Risor syntax is that it is like Go, but aims to be more
concise and expressive for scripting. Variables are dynamically typed and all
Risor object types implement an `object.Object` interface defined in Go.

### Variable Declarations

Variables are declared using the := operator. Unlike in Go, all variables
are dynamically typed.

```risor copy
// Declare a variable `x` and assign the integer value 10
x := 10

// Declare a variable `y` and assign the string value "hello"
y := "hello"

// Declare a variable `array` and assign an array of integers
array := [1, 2, 3]
```

Constant declarations are also supported:

```risor copy
const url = "https://example.com"
```

### Variable Assignment

Existing variables can be set using the = operator:

```risor copy
// Declare `x`
x := 10

// Update `x` to 20
x = 20
```

### Functions

Functions in Risor are declared using the `func` keyword. Type declarations are
not supported.

```risor copy
func last(data) {
    if len(data) == 0 {
        return nil
    }
    return data[-1]
}
```

Default parameter values are supported, with allowed types including strings,
integers, floats, and booleans:

```risor copy
func greet(name='world') {
    return 'Hello, ' + name
}
```

Unlike in Go, functions can only return a single value. You can, however, return
a list and unpack it:

```risor copy
func swap(a, b) {
    return [b, a]
}

x, y := swap(10, 20)
print(x, y)  // 20 10
```

Functions may be assigned to a variable and passed as values:

```risor copy
add := func(a, b) {
    return a + b
}

result := add(10, 20) // 30
```

### Control Flow

Risor supports most forms of control flow present in Go.

```risor copy
x := 10
threshold := 5
if x > threshold {
    print("greater")
} else if x == threshold {
    print("equal")
} else {
    print("lesser")
}
```

One difference with Risor is that if-else and switch are expressions in Risor,
meaning they evaluate to a value.

```risor copy
x := if 10 > 5 {
    "greater"
} else {
    "lesser"
}

print(x)  # "greater"
```

```risor copy
name := "Alice"
x := switch name {
    case "Joe":
        "Hello, Joe"
    default:
        "Hello, stranger"
}
print(x)  # "Hello, Joe"
```

Ternary expressions are supported:

```risor copy
x := 10 > 5 ? 1 : 0
print(x) // 1
```

### Loops

Risor supports for loops and range loops in the same way as Go.

```risor copy
for i := 0; i < 5; i++ {
    print(i)
}
```

```risor copy
i := 0
for i < 5 {
    print(i)
    i++
}
```

```risor copy
array := [1, 2, 3]
for i, value := range array {
    print(i, value)
}
```

```risor copy
for {
    print("infinite loop")
    time.sleep(1)
}
```

`break` and `continue` keywords are also supported.

```risor copy
for i := 0; i < 10; i++ {
    if i == 5 {
        break
    }
    print(i)
}
```

```risor copy
for i := 0; i < 10; i++ {
    if i == 5 {
        continue
    }
    print(i)
}
```

### Errors

Risor errors are similar to exceptions in languages like Python and Javascript.
This makes Risor more concise and suitable for scripts, as compared to Go. A
built-in `try` function is provided to attempt an operation and fallback to a
default value if it fails. `try` accepts any number of functions, and the first
one that does not raise an error has its result returned. If a non-function value
is reached, it is returned immediately.

```risor copy
result := try(func() { error("kaboom") }, "default value")
print(result)  # "default value"
```

Errors can be raised using the `error` function:

```risor copy
func divide(a, b) {
    if b == 0 {
        error("bad idea: division by zero")
    }
    return a / b
}
```

Also see the [Try-Catch Error Handling](syntax#try-catch-error-handling) section
for more information.

### Pipe Expressions

Risor supports pipe expressions, which allow you to chain function calls
together. The pipe operator `|` takes the result of the expression on its left
and passes it as the first argument to the function on its right.

```risor copy
result := "hello" | strings.to_upper
print(result)  # "HELLO"
```

### Importing Modules

Modules are imported using the `import` keyword.

```risor copy
import mymod

import mymod as mod
```

By default the Risor CLI will look for modules as `.risor` files in the
current working directory.

You can also import specific attributes from a module using the `from` keyword.

```risor copy
from mymod import myfunc

from mymod import myfunc as f
```

### Strings

Simple strings are declared using double quotes, as in Go:

```risor copy
s := "hello"
```

Multiline, raw strings are also supported using backticks:

```risor copy
s := `
"one"
"two"
`
```

Templated strings are defined using single quotes, and variables are interpolated
between curly braces:

```risor copy
name := "Joe"
s := 'Hello, {name}'
```

### Data Structures

Risor supports lists, maps, and sets.

```risor copy
// Values contained in data structures can hold mixed types
mylist := [1, "two", 3.0]

// Map keys are always strings
mymap := {
    "one": 1,
    "two": 2,
    "three": 3,
}

othermap := {
    foo: "bar" // keys can be unquoted if they are valid identifiers
}

myset := {1, 2, 3}
```

Membership tests are performed using the `in` operator:

```risor copy
mylist := [1, 2, 3]
print(1 in mylist)  // true
```

### Comments

Single-line comments are defined using `//` or `#`, and multiline comments are
defined using `/*` and `*/`.

```risor copy
// This is a single-line comment

# This is also a single-line comment

/* 
This is a multiline comment
*/
```

### Channels

Risor supports Go-style channels for concurrent communication:

```risor copy
// Create a buffered channel with capacity 1
c := chan(1)

// Send a value to the channel
c <- "hello"

// Receive a value from the channel
x := <-c

// Close a channel
close(c)
```

Risor channels behave like Go channels in many ways, however they support sending
and receiving any Risor object type. Also when ranging over a channel, in Risor
you receive both the index and value of the current item.

```risor copy
func work(count) {
    mychan := chan(5)
    go func() {
        for i := 0; i < count; i++ {
            mychan <- rand.float()
        }
        close(mychan)
    }()
    return mychan
}

// Different from Go: ranging over a channel yields both the index and value
for i, value := range work(5) {
    print(i, value)
}
```

### Goroutines

Risor supports launching goroutines using the `go` keyword:

```risor copy
// Launch a goroutine
go func() {
    // Do some work
}()

// Use a channel for communication
c := chan(1)
go func() {
    c <- 42
}()
x := <-c
```

### Spawn

The `spawn` function spawns a new goroutine and returns a `thread` object. The
thread object can be used to wait for the goroutine to finish and retrieve its
return value.

```risor copy
// Spawn a function and wait for its result
result := spawn(func(x) { return x * 2 }, 21).wait()
print(result)  // 42

// Spawn multiple functions
threads := []
for i := 0; i < 5; i++ {
    threads.append(spawn(func(x) { return x ** 2 }, i))
}
results := threads.map(func(t) { t.wait() })
print(results)  // [0, 1, 4, 9, 16]
```

### Defer

The `defer` statement allows you to schedule a function call to be run after the
current function completes:

```risor copy
func example() {
    defer print("This will be printed last")
    print("This will be printed first")
}

example()
```

### Try-Catch Error Handling

Risor provides a `try` function for error handling:

```risor copy
result := try(
    func() {
        // Code that might raise an error
        error("Something went wrong")
    },
    func(err) {
        // Error handler
        print("Caught error:", err)
        return "fallback value"
    }
)
```

See the [try](builtins#try) built-in for more information.


---
context/docs/typeconv.go
---
package object

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"reflect"
	"time"
	"unicode/utf8"

	"github.com/risor-io/risor/compiler"
	"github.com/risor-io/risor/errz"
)

var kindConverters = map[reflect.Kind]TypeConverter{
	reflect.Bool:    &BoolConverter{},
	reflect.Int:     &IntConverter{},
	reflect.Int8:    &Int8Converter{},
	reflect.Int16:   &Int16Converter{},
	reflect.Int32:   &Int32Converter{},
	reflect.Int64:   &Int64Converter{},
	reflect.Uint:    &UintConverter{},
	reflect.Uint8:   &Uint8Converter{},
	reflect.Uint16:  &Uint16Converter{},
	reflect.Uint32:  &Uint32Converter{},
	reflect.Uint64:  &Uint64Converter{},
	reflect.Float32: &Float32Converter{},
	reflect.Float64: &Float64Converter{},
	reflect.String:  &StringConverter{},
}

var typeConverters = map[reflect.Type]TypeConverter{
	reflect.TypeOf(byte(0)):              &ByteConverter{},
	reflect.TypeOf(time.Time{}):          &TimeConverter{},
	reflect.TypeOf(bytes.NewBuffer(nil)): &BufferConverter{},
	reflect.TypeOf([]byte{}):             &ByteSliceConverter{},
	reflect.TypeOf([]float64{}):          &FloatSliceConverter{},
}

// Kinds do NOT intend to handle for now:
// * Chan
// * Complex64
// * Complex128
// * UnsafePointer

// *****************************************************************************
// Type assertion helpers
// *****************************************************************************

func AsBool(obj Object) (bool, *Error) {
	b, ok := obj.(*Bool)
	if !ok {
		return false, TypeErrorf("type error: expected a bool (%s given)", obj.Type())
	}
	return b.value, nil
}

func AsString(obj Object) (string, *Error) {
	switch obj := obj.(type) {
	case *String:
		return obj.value, nil
	case *ByteSlice:
		return string(obj.value), nil
	case *Buffer:
		return obj.value.String(), nil
	default:
		return "", TypeErrorf("type error: expected a string (%s given)", obj.Type())
	}
}

func AsInt(obj Object) (int64, *Error) {
	switch obj := obj.(type) {
	case *Int:
		return obj.value, nil
	case *Byte:
		return int64(obj.value), nil
	default:
		return 0, TypeErrorf("type error: expected an integer (%s given)", obj.Type())
	}
}

func AsByte(obj Object) (byte, *Error) {
	switch obj := obj.(type) {
	case *Int:
		return byte(obj.value), nil
	case *Byte:
		return obj.value, nil
	case *Float:
		return byte(obj.value), nil
	case *String:
		if len(obj.value) != 1 {
			return 0, TypeErrorf("type error: expected a single byte string (length %d)", len(obj.value))
		}
		return obj.value[0], nil
	default:
		return 0, TypeErrorf("type error: expected a byte (%s given)", obj.Type())
	}
}

func AsFloat(obj Object) (float64, *Error) {
	switch obj := obj.(type) {
	case *Int:
		return float64(obj.value), nil
	case *Byte:
		return float64(obj.value), nil
	case *Float:
		return obj.value, nil
	default:
		return 0.0, TypeErrorf("type error: expected a number (%s given)", obj.Type())
	}
}

func AsList(obj Object) (*List, *Error) {
	list, ok := obj.(*List)
	if !ok {
		return nil, TypeErrorf("type error: expected a list (%s given)", obj.Type())
	}
	return list, nil
}

func AsStringSlice(obj Object) ([]string, *Error) {
	list, ok := obj.(*List)
	if !ok {
		return nil, TypeErrorf("type error: expected a list (%s given)", obj.Type())
	}
	result := make([]string, 0, len(list.items))
	for _, item := range list.items {
		s, err := AsString(item)
		if err != nil {
			return nil, err
		}
		result = append(result, s)
	}
	return result, nil
}

func AsMap(obj Object) (*Map, *Error) {
	m, ok := obj.(*Map)
	if !ok {
		return nil, TypeErrorf("type error: expected a map (%s given)", obj.Type())
	}
	return m, nil
}

func AsTime(obj Object) (result time.Time, err *Error) {
	s, ok := obj.(*Time)
	if !ok {
		return time.Time{}, TypeErrorf("type error: expected a time (%s given)", obj.Type())
	}
	return s.value, nil
}

func AsSet(obj Object) (*Set, *Error) {
	set, ok := obj.(*Set)
	if !ok {
		return nil, TypeErrorf("type error: expected a set (%s given)", obj.Type())
	}
	return set, nil
}

func AsBytes(obj Object) ([]byte, *Error) {
	switch obj := obj.(type) {
	case *ByteSlice:
		return obj.value, nil
	case *Buffer:
		return obj.value.Bytes(), nil
	case *String:
		return []byte(obj.value), nil
	case io.Reader:
		bytes, err := io.ReadAll(obj)
		if err != nil {
			return nil, NewError(err)
		}
		return bytes, nil
	default:
		return nil, TypeErrorf("type error: expected bytes (%s given)", obj.Type())
	}
}

func AsReader(obj Object) (io.Reader, *Error) {
	if o, ok := obj.(interface{ AsReader() (io.Reader, *Error) }); ok {
		return o.AsReader()
	}
	switch obj := obj.(type) {
	case *ByteSlice:
		return bytes.NewBuffer(obj.value), nil
	case *String:
		return bytes.NewBufferString(obj.value), nil
	case *File:
		return obj.value, nil
	case io.Reader:
		return obj, nil
	default:
		return nil, TypeErrorf("type error: expected a readable object (%s given)", obj.Type())
	}
}

func AsWriter(obj Object) (io.Writer, *Error) {
	if o, ok := obj.(interface{ AsWriter() (io.Writer, *Error) }); ok {
		return o.AsWriter()
	}
	switch obj := obj.(type) {
	case *Buffer:
		return obj.value, nil
	case *File:
		return obj.value, nil
	case io.Writer:
		return obj, nil
	default:
		return nil, TypeErrorf("type error: expected a writable object (%s given)", obj.Type())
	}
}

func AsIterator(obj Object) (Iterator, *Error) {
	switch obj := obj.(type) {
	case Iterator:
		return obj, nil
	case Iterable:
		return obj.Iter(), nil
	default:
		return nil, TypeErrorf("type error: expected an iterable object (%s given)", obj.Type())
	}
}

func AsError(obj Object) (*Error, *Error) {
	err, ok := obj.(*Error)
	if !ok {
		return nil, TypeErrorf("type error: expected an error object (%s given)", obj.Type())
	}
	return err, nil
}

// *****************************************************************************
// Converting types from Go to Risor
// *****************************************************************************

func FromGoType(obj interface{}) Object {
	switch obj := obj.(type) {
	case nil:
		return Nil
	case int:
		return NewInt(int64(obj))
	case int16:
		return NewInt(int64(obj))
	case int32:
		return NewInt(int64(obj))
	case int64:
		return NewInt(obj)
	case uint:
		return NewInt(int64(obj))
	case uint16:
		return NewInt(int64(obj))
	case uint32:
		return NewInt(int64(obj))
	case uint64:
		return NewInt(int64(obj))
	case float32:
		return NewFloat(float64(obj))
	case float64:
		return NewFloat(obj)
	case json.Number:
		if n, err := obj.Float64(); err == nil {
			return NewFloat(n)
		}
		return NewString(obj.String())
	case string:
		return NewString(obj)
	case []string:
		return NewStringList(obj)
	case byte:
		return NewByte(obj)
	case []byte:
		return NewByteSlice(obj)
	case *bytes.Buffer:
		return NewBuffer(obj)
	case *compiler.Function:
		return NewFunction(obj)
	case bool:
		if obj {
			return True
		}
		return False
	// case [16]uint8:
	// 	return NewString(uuid.UUID(obj).String())
	case time.Time:
		return NewTime(obj)
	case []interface{}:
		items := make([]Object, 0, len(obj))
		for _, item := range obj {
			listItem := FromGoType(item)
			if IsError(listItem) {
				return listItem
			}
			items = append(items, listItem)
		}
		return NewList(items)
	case map[string]interface{}:
		m := make(map[string]Object, len(obj))
		for k, v := range obj {
			valueObj := FromGoType(v)
			if IsError(valueObj) {
				return valueObj
			}
			m[k] = valueObj
		}
		return NewMap(m)
	case Object:
		return obj
	default:
		return TypeErrorf("type error: unmarshaling %v (%v)",
			obj, reflect.TypeOf(obj))
	}
}

// AsObjects transform a map containing arbitrary Go types to a map of
// Risor objects, using the best type converter for each type. If an item
// in the map is of a type that can't be converted, an error is returned.
func AsObjects(m map[string]any) (map[string]Object, error) {
	result := make(map[string]Object, len(m))
	for k, v := range m {
		switch v := v.(type) {
		case Object:
			result[k] = v
		default:
			converter, err := NewTypeConverter(reflect.TypeOf(v))
			if err != nil {
				return nil, err
			}
			value, err := converter.From(v)
			if err != nil {
				return nil, err
			}
			result[k] = value
		}
	}
	return result, nil
}

// *****************************************************************************
// TypeConverter interface and implementations
//   - These are applicable when the Go type(s) are known in advance
// *****************************************************************************

// TypeConverter is an interface used to convert between Go and Risor objects
// for a single Go type.
type TypeConverter interface {
	// To converts to a Go object from a Risor object.
	To(Object) (interface{}, error)

	// From converts a Go object to a Risor object.
	From(interface{}) (Object, error)
}

// NewTypeConverter returns a TypeConverter for the given Go kind and type.
// Converters are cached internally for reuse.
func NewTypeConverter(typ reflect.Type) (TypeConverter, error) {
	goTypeMutex.Lock()
	defer goTypeMutex.Unlock()

	return createTypeConverter(typ)
}

// The caller must hold the goTypeMutex lock.
func createTypeConverter(typ reflect.Type) (TypeConverter, error) {
	if conv, ok := typeConverters[typ]; ok {
		return conv, nil
	}
	conv, err := getTypeConverter(typ)
	if err != nil {
		return nil, err
	}
	typeConverters[typ] = conv
	return conv, nil
}

// SetTypeConverter sets a TypeConverter for the given Go type. This is not
// typically used, since the default converters should typically be sufficient.
func SetTypeConverter(typ reflect.Type, conv TypeConverter) {
	goTypeMutex.Lock()
	defer goTypeMutex.Unlock()

	typeConverters[typ] = conv
}

// getTypeConverter returns a TypeConverter for the given Go type.
// The caller must hold the goTypeMutex lock.
func getTypeConverter(typ reflect.Type) (TypeConverter, error) {
	kind := typ.Kind()
	if conv, ok := kindConverters[kind]; ok {
		return conv, nil
	}
	if conv, ok := typeConverters[typ]; ok {
		return conv, nil
	}
	var err error
	var converter TypeConverter
	switch kind {
	case reflect.Struct:
		converter, err = newStructConverter(typ)
		if err != nil {
			return nil, err
		}
	case reflect.Pointer:
		indirectType := typ.Elem()
		if indirectKind := indirectType.Kind(); indirectKind == reflect.Struct {
			converter, err = newStructConverter(typ)
			if err != nil {
				return nil, err
			}
		} else {
			converter, err = newPointerConverter(typ.Elem())
			if err != nil {
				return nil, err
			}
		}
	case reflect.Slice:
		converter, err = newSliceConverter(typ.Elem())
		if err != nil {
			return nil, err
		}
	case reflect.Array:
		converter, err = newArrayConverter(typ.Elem(), typ.Len())
		if err != nil {
			return nil, err
		}
	case reflect.Map:
		if typ.Key().Kind() == reflect.String {
			converter, err = newMapConverter(typ.Elem())
			if err != nil {
				return nil, err
			}
		} else {
			return nil, errz.TypeErrorf("type error: unsupported map key type in %s", typ)
		}
	case reflect.Interface:
		if typ.Implements(errorInterface) {
			converter = &ErrorConverter{}
		} else if typ.Implements(contextInterface) {
			converter = &ContextConverter{}
		} else { // TODO: io.*?
			converter = &DynamicConverter{}
		}
	default:
		return nil, errz.TypeErrorf("type error: unsupported kind: %s", kind)
	}
	return converter, nil
}

// BoolConverter converts between bool and *Bool.
type BoolConverter struct{}

func (c *BoolConverter) To(obj Object) (interface{}, error) {
	b, ok := obj.(*Bool)
	if !ok {
		return nil, errz.TypeErrorf("type error: expected bool (%s given)", obj.Type())
	}
	return b.value, nil
}

func (c *BoolConverter) From(obj interface{}) (Object, error) {
	return NewBool(obj.(bool)), nil
}

// ByteConverter converts between byte and *Byte.
type ByteConverter struct{}

func (c *ByteConverter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return obj.value, nil
	case *Int:
		return byte(obj.value), nil
	case *Float:
		return byte(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected byte (%s given)", obj.Type())
	}
}

func (c *ByteConverter) From(obj interface{}) (Object, error) {
	return NewByte(obj.(byte)), nil
}

// RuneConverter converts between rune and *String.
type RuneConverter struct{}

func (c *RuneConverter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *String:
		if len(obj.value) != 1 {
			return nil, errz.TypeErrorf("type error: expected single rune string (got length %d)", len(obj.value))
		}
		r, _ := utf8.DecodeRuneInString(obj.value)
		return r, nil
	case *Int:
		return rune(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected string (%s given)", obj.Type())
	}
}

func (c *RuneConverter) From(obj interface{}) (Object, error) {
	return NewString(string([]rune{obj.(rune)})), nil
}

// IntConverter converts between int and *Int.
type IntConverter struct{}

func (c *IntConverter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return int(obj.value), nil
	case *Int:
		return int(obj.value), nil
	case *Float:
		return int(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected int (%s given)", obj.Type())
	}
}

func (c *IntConverter) From(obj interface{}) (Object, error) {
	return NewInt(int64(obj.(int))), nil
}

// Int8Converter converts between int8 and *Int.
type Int8Converter struct{}

func (c *Int8Converter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return int8(obj.value), nil
	case *Int:
		return int8(obj.value), nil
	case *Float:
		return int8(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected int (%s given)", obj.Type())
	}
}

func (c *Int8Converter) From(obj interface{}) (Object, error) {
	return NewInt(int64(obj.(int8))), nil
}

// Int16Converter converts between int16 and *Int.
type Int16Converter struct{}

func (c *Int16Converter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return int16(obj.value), nil
	case *Int:
		return int16(obj.value), nil
	case *Float:
		return int16(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected int (%s given)", obj.Type())
	}
}

func (c *Int16Converter) From(obj interface{}) (Object, error) {
	return NewInt(int64(obj.(int16))), nil
}

// Int32Converter converts between int32 and *Int.
type Int32Converter struct{}

func (c *Int32Converter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return int32(obj.value), nil
	case *Int:
		return int32(obj.value), nil
	case *Float:
		return int32(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected int (%s given)", obj.Type())
	}
}

func (c *Int32Converter) From(obj interface{}) (Object, error) {
	return NewInt(int64(obj.(int32))), nil
}

// Int64Converter converts between int64 and *Int.
type Int64Converter struct{}

func (c *Int64Converter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return int64(obj.value), nil
	case *Int:
		return int64(obj.value), nil
	case *Float:
		return int64(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected int (%s given)", obj.Type())
	}
}

func (c *Int64Converter) From(obj interface{}) (Object, error) {
	return NewInt(obj.(int64)), nil
}

// UintConverter converts between uint and *Int.
type UintConverter struct{}

func (c *UintConverter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return uint(obj.value), nil
	case *Int:
		return uint(obj.value), nil
	case *Float:
		return uint(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected int (%s given)", obj.Type())
	}
}

func (c *UintConverter) From(obj interface{}) (Object, error) {
	return NewInt(int64(obj.(uint))), nil
}

// Uint8Converter converts between uint8 and *Int.
type Uint8Converter struct{}

func (c *Uint8Converter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return uint8(obj.value), nil
	case *Int:
		return uint8(obj.value), nil
	case *Float:
		return uint8(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected int (%s given)", obj.Type())
	}
}

func (c *Uint8Converter) From(obj interface{}) (Object, error) {
	return NewInt(int64(obj.(uint8))), nil
}

// Uint16Converter converts between uint16 and *Int.
type Uint16Converter struct{}

func (c *Uint16Converter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return uint16(obj.value), nil
	case *Int:
		return uint16(obj.value), nil
	case *Float:
		return uint16(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected int (%s given)", obj.Type())
	}
}

func (c *Uint16Converter) From(obj interface{}) (Object, error) {
	return NewInt(int64(obj.(uint16))), nil
}

// Uint32Converter converts between uint32 and *Int.
type Uint32Converter struct{}

func (c *Uint32Converter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return uint32(obj.value), nil
	case *Int:
		return uint32(obj.value), nil
	case *Float:
		return uint32(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected int (%s given)", obj.Type())
	}
}

func (c *Uint32Converter) From(obj interface{}) (Object, error) {
	return NewInt(int64(obj.(uint32))), nil
}

// Uint64Converter converts between uint64 and *Int.
type Uint64Converter struct{}

func (c *Uint64Converter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return uint64(obj.value), nil
	case *Int:
		return uint64(obj.value), nil
	case *Float:
		return uint64(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected int (%s given)", obj.Type())
	}
}

func (c *Uint64Converter) From(obj interface{}) (Object, error) {
	return NewInt(int64(obj.(uint64))), nil
}

// Float32Converter converts between float32 and *Float.
type Float32Converter struct{}

func (c *Float32Converter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return float32(obj.value), nil
	case *Int:
		return float32(obj.value), nil
	case *Float:
		return float32(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected float (%s given)", obj.Type())
	}
}

func (c *Float32Converter) From(obj interface{}) (Object, error) {
	return NewFloat(float64(obj.(float32))), nil
}

// Float64Converter converts between float64 and *Float.
type Float64Converter struct{}

func (c *Float64Converter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Byte:
		return float64(obj.value), nil
	case *Int:
		return float64(obj.value), nil
	case *Float:
		return obj.value, nil
	default:
		return nil, errz.TypeErrorf("type error: expected float (%s given)", obj.Type())
	}
}

func (c *Float64Converter) From(obj interface{}) (Object, error) {
	return NewFloat(obj.(float64)), nil
}

// StringConverter converts between string and *String.
type StringConverter struct{}

func (c *StringConverter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *ByteSlice:
		return string(obj.value), nil
	case *Buffer:
		return obj.value.String(), nil
	case *String:
		return obj.value, nil
	default:
		return nil, errz.TypeErrorf("type error: expected string (%s given)", obj.Type())
	}
}

func (c *StringConverter) From(obj interface{}) (Object, error) {
	return NewString(obj.(string)), nil
}

// ByteSliceConverter converts between []byte and *ByteSlice.
type ByteSliceConverter struct{}

func (c *ByteSliceConverter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *ByteSlice:
		return obj.value, nil
	case *Buffer:
		return obj.value.Bytes(), nil
	case *String:
		return []byte(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected bytes (%s given)", obj.Type())
	}
}

func (c *ByteSliceConverter) From(obj interface{}) (Object, error) {
	return NewByteSlice(obj.([]byte)), nil
}

// FloatSliceConverter converts between []float64 and *FloatSlice.
type FloatSliceConverter struct{}

func (c *FloatSliceConverter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *FloatSlice:
		return obj.value, nil
	default:
		return nil, errz.TypeErrorf("type error: expected float_slice (%s given)", obj.Type())
	}
}

func (c *FloatSliceConverter) From(obj interface{}) (Object, error) {
	return NewFloatSlice(obj.([]float64)), nil
}

// TimeConverter converts between time.Time and *Time.
type TimeConverter struct{}

func (c *TimeConverter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Time:
		return obj.value, nil
	case *String:
		return time.Parse(time.RFC3339, obj.value)
	default:
		return nil, errz.TypeErrorf("type error: expected time (%s given)", obj.Type())
	}
}

func (c *TimeConverter) From(obj interface{}) (Object, error) {
	return NewTime(obj.(time.Time)), nil
}

// BufferConverter converts between *bytes.Buffer and *Buffer.
type BufferConverter struct{}

func (c *BufferConverter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Buffer:
		return obj.value, nil
	case *ByteSlice:
		return bytes.NewBuffer(obj.value), nil
	default:
		return nil, errz.TypeErrorf("type error: expected buffer (%s given)", obj.Type())
	}
}

func (c *BufferConverter) From(obj interface{}) (Object, error) {
	return NewBuffer(obj.(*bytes.Buffer)), nil
}

// DynamicConverter converts between interface{} and the appropriate Risor type.
// This is slow and should only be used to handle unknown types.
type DynamicConverter struct{}

func (c *DynamicConverter) To(obj Object) (interface{}, error) {
	return obj.Interface(), nil
}

func (c *DynamicConverter) From(obj interface{}) (Object, error) {
	if obj == nil {
		return Nil, nil
	}
	typ := reflect.TypeOf(obj)
	conv, err := NewTypeConverter(typ)
	if err != nil {
		return nil, err
	}
	return conv.From(obj)
}

// MapConverter converts between map[string]interface{} and *Map.
type MapConverter struct {
	valueConverter TypeConverter
	valueType      reflect.Type
}

func (c *MapConverter) To(obj Object) (interface{}, error) {
	if obj.Type() == NIL {
		return nil, nil
	}
	tMap, ok := obj.(*Map)
	if !ok {
		return nil, errz.TypeErrorf("type error: expected map (%s given)", obj.Type())
	}
	keyType := reflect.TypeOf("")
	mapType := reflect.MapOf(keyType, c.valueType)
	gMap := reflect.MakeMapWithSize(mapType, tMap.Size())
	for k, v := range tMap.items {
		conv, err := c.valueConverter.To(v)
		if err != nil {
			return nil, err
		}
		gMap.SetMapIndex(reflect.ValueOf(k), reflect.ValueOf(conv))
	}
	return gMap.Interface(), nil
}

func (c *MapConverter) From(obj interface{}) (Object, error) {
	m := reflect.ValueOf(obj)
	o := make(map[string]Object, m.Len())
	for _, key := range m.MapKeys() {
		v := m.MapIndex(key)
		conv, err := c.valueConverter.From(v.Interface())
		if err != nil {
			return nil, err
		}
		o[key.Interface().(string)] = conv
	}
	return NewMap(o), nil
}

func newMapConverter(valueType reflect.Type) (*MapConverter, error) {
	valueConverter, err := createTypeConverter(valueType)
	if err != nil {
		return nil, errz.TypeErrorf("type error: unsupported map value type %s", valueType)
	}
	return &MapConverter{
		valueConverter: valueConverter,
		valueType:      valueType,
	}, nil
}

// StructConverter converts between a Go struct and a Risor Proxy.
// Works with structs as values or pointers.
type StructConverter struct {
	typ    reflect.Type
	goType *GoType
}

func (c *StructConverter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Proxy:
		// Return the object wrapped by the proxy
		return obj.obj, nil
	case *Map:
		// Create a new struct. The "value" here is a pointer to the new struct.
		value := c.goType.New()
		// Get the underlying struct so that we can set its fields.
		structValue := value.Elem()
		for k, value := range obj.items {
			// If the struct has a field with the same name as a key, set it.
			if f := structValue.FieldByName(k); f.CanSet() {
				if attr, ok := c.goType.GetAttribute(k); ok {
					if attrField, ok := attr.(*GoField); ok {
						attrValue, err := attrField.converter.To(value)
						if err != nil {
							return nil, err
						}
						f.Set(reflect.ValueOf(attrValue))
					}
				}
			}
		}
		if c.goType.IsPointerType() {
			return value.Interface(), nil
		}
		return structValue.Interface(), nil
	default:
		return nil, errz.TypeErrorf("type error: expected a proxy or map (%s given)", obj.Type())
	}
}

func (c *StructConverter) From(obj interface{}) (Object, error) {
	// Sanity check that the object is of the expected type
	typ := reflect.TypeOf(obj)
	if typ != c.typ {
		return nil, errz.TypeErrorf("type error: expected %s (%s given)", c.typ, typ)
	}
	// Wrap the object in a proxy
	return NewProxy(obj)
}

// newStructConverter creates a TypeConverter for a given type of struct.
func newStructConverter(typ reflect.Type) (*StructConverter, error) {
	goType, err := newGoType(typ)
	if err != nil {
		return nil, err
	}
	return &StructConverter{typ: typ, goType: goType}, nil
}

// PointerConverter converts between *T and the Risor equivalent of T.
type PointerConverter struct {
	valueConverter TypeConverter
}

func (c *PointerConverter) To(obj Object) (interface{}, error) {
	if obj.Type() == NIL {
		return nil, nil
	}
	v, err := c.valueConverter.To(obj)
	if err != nil {
		return nil, err
	}
	vp := reflect.New(reflect.TypeOf(v))
	vp.Elem().Set(reflect.ValueOf(v))
	return vp.Interface(), nil
}

func (c *PointerConverter) From(obj interface{}) (Object, error) {
	v := reflect.ValueOf(obj)
	if v.IsZero() {
		return Nil, nil
	}
	return c.valueConverter.From(v.Elem().Interface())
}

// newPointerConverter creates a TypeConverter for pointers that point to
// items of the given type.
func newPointerConverter(indirectType reflect.Type) (*PointerConverter, error) {
	indirectConv, err := createTypeConverter(indirectType)
	if err != nil {
		return nil, err
	}
	return &PointerConverter{valueConverter: indirectConv}, nil
}

// SliceConverter converts between []T and the Risor equivalent of []T.
type SliceConverter struct {
	valueConverter TypeConverter
	valueType      reflect.Type
}

func (c *SliceConverter) To(obj Object) (interface{}, error) {
	if obj.Type() == NIL {
		return nil, nil
	}
	list, ok := obj.(*List)
	if !ok {
		return nil, errz.TypeErrorf("type error: expected a list (%s given)", obj.Type())
	}
	slice := reflect.MakeSlice(reflect.SliceOf(c.valueType), 0, len(list.items))
	for _, v := range list.items {
		item, err := c.valueConverter.To(v)
		if err != nil {
			return nil, errz.TypeErrorf("type error: failed to convert slice element: %v", err)
		}
		slice = reflect.Append(slice, reflect.ValueOf(item))
	}
	return slice.Interface(), nil
}

func (c *SliceConverter) From(iface interface{}) (Object, error) {
	v := reflect.ValueOf(iface)
	count := v.Len()
	items := make([]Object, 0, count)
	for i := 0; i < count; i++ {
		item, err := c.valueConverter.From(v.Index(i).Interface())
		if err != nil {
			return nil, errz.TypeErrorf("type error: failed to convert slice element: %v", err)
		}
		items = append(items, item)
	}
	return NewList(items), nil
}

// newSliceConverter creates a TypeConverter for slices containing the given
// value type, where the items can be converted using the given TypeConverter.
func newSliceConverter(indirectType reflect.Type) (*SliceConverter, error) {
	indirectConv, err := createTypeConverter(indirectType)
	if err != nil {
		return nil, err
	}
	return &SliceConverter{
		valueType:      indirectType,
		valueConverter: indirectConv,
	}, nil
}

// ArrayConverter converts between []T and the Risor equivalent of []T.
type ArrayConverter struct {
	valueConverter TypeConverter
	valueType      reflect.Type
	len            int
}

func (c *ArrayConverter) To(obj Object) (interface{}, error) {
	list, ok := obj.(*List)
	if !ok {
		return nil, errz.TypeErrorf("type error: expected a list (%s given)", obj.Type())
	}
	array := reflect.New(reflect.ArrayOf(c.len, c.valueType))
	arrayElem := array.Elem()
	for i, v := range list.items {
		item, err := c.valueConverter.To(v)
		if err != nil {
			return nil, errz.TypeErrorf("type error: failed to convert element: %v", err)
		}
		arrayElem.Index(i).Set(reflect.ValueOf(item))
	}
	return arrayElem.Interface(), nil
}

func (c *ArrayConverter) From(iface interface{}) (Object, error) {
	v := reflect.ValueOf(iface)
	count := v.Len()
	items := make([]Object, 0, count)
	for i := 0; i < count; i++ {
		item, err := c.valueConverter.From(v.Index(i).Interface())
		if err != nil {
			return nil, errz.TypeErrorf("type error: failed to convert slice element: %v", err)
		}
		items = append(items, item)
	}
	return NewList(items), nil
}

// newArrayConverter creates a TypeConverter for arrays containing the given
// value type, where the items can be converted using the given TypeConverter.
func newArrayConverter(indirectType reflect.Type, length int) (*ArrayConverter, error) {
	if length < 0 {
		return nil, fmt.Errorf("value error: invalid array length: %d", length)
	}
	indirectConv, err := createTypeConverter(indirectType)
	if err != nil {
		return nil, err
	}
	return &ArrayConverter{
		valueType:      indirectType,
		valueConverter: indirectConv,
		len:            length,
	}, nil
}

// ErrorConverter converts between error and *Error or *String.
type ErrorConverter struct{}

func (c *ErrorConverter) To(obj Object) (interface{}, error) {
	switch obj := obj.(type) {
	case *Error:
		return obj.Value(), nil
	case *String:
		return errors.New(obj.Value()), nil
	default:
		return nil, errz.TypeErrorf("type error: expected a string (%s given)", obj.Type())
	}
}

func (c *ErrorConverter) From(obj interface{}) (Object, error) {
	return NewError(obj.(error)), nil
}

// ContextConverter converts between context.Context and Context.
type ContextConverter struct{}

func (c *ContextConverter) To(obj Object) (interface{}, error) {
	// Not actually called, but needed to satisfy the Converter interface.
	return nil, errors.New("not implemented")
}

func (c *ContextConverter) From(obj interface{}) (Object, error) {
	// Not actually called, but needed to satisfy the Converter interface.
	return nil, errors.New("not implemented")
}


---
context/examples/chrono-src/LICENSE
---
MIT License

Copyright (c) 2021 Procyon

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


---
context/examples/chrono-src/README.md
---
![Chrono Logo](https://user-images.githubusercontent.com/5354910/196008920-1ca88967-3d7d-449c-b165-fe38c5e1fb57.png)
# Chrono
[![Go Report Card](https://goreportcard.com/badge/codnect.io/chrono)](https://goreportcard.com/report/codnect.io/chrono)
[![CircleCI](https://dl.circleci.com/status-badge/img/gh/procyon-projects/chrono/tree/main.svg?style=svg)](https://dl.circleci.com/status-badge/redirect/gh/procyon-projects/chrono/tree/main)
[![codecov](https://codecov.io/gh/procyon-projects/chrono/branch/main/graph/badge.svg?token=OREV0YI8VU)](https://codecov.io/gh/procyon-projects/chrono)

Chrono is a scheduler library that lets you run your tasks and code periodically. It provides different scheduling functionalities to make it easier to create a scheduling task.

## Scheduling a One-Shot Task
The Schedule method helps us schedule the task to run once at the specified time. In the following example, the task will first be executed 1 second after the current time.
**WithTime** option is used to specify the execution time.

```go
taskScheduler := chrono.NewDefaultTaskScheduler()
now := time.Now()
startTime := now.Add(time.Second * 1)

task, err := taskScheduler.Schedule(func(ctx context.Context) {
	log.Print("One-Shot Task")
}, chrono.WithTime(startTime))

if err == nil {
	log.Print("Task has been scheduled successfully.")
}
```

Also, **WithStartTime** option can be used to specify the execution time. **But It's deprecated.**

```go
taskScheduler := chrono.NewDefaultTaskScheduler()

task, err := taskScheduler.Schedule(func(ctx context.Context) {
	log.Print("One-Shot Task")
}, chrono.WithStartTime(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()+1))

if err == nil {
	log.Print("Task has been scheduled successfully.")
}
```

## Scheduling a Task with Fixed Delay
Let's schedule a task to run with a fixed delay between the finish time of the last execution of the task and the start time of the next execution of the task.
The fixed delay counts the delay after the completion of the last execution.

```go
taskScheduler := chrono.NewDefaultTaskScheduler()

task, err := taskScheduler.ScheduleWithFixedDelay(func(ctx context.Context) {
	log.Print("Fixed Delay Task")
	time.Sleep(3 * time.Second)
}, 5 * time.Second)

if err == nil {
	log.Print("Task has been scheduled successfully.")
}
```

Since the task itself takes 3 seconds to complete and we have specified a delay of 5 seconds between the finish time of the last execution of the task and the start time of the next execution of the task, there will be a delay of 8 seconds between each execution.

**WithStartTime** and **WithLocation** options can be combined with this.

## Schedule Task at a Fixed Rate
Let's schedule a task to run at a fixed rate of seconds.

```go
taskScheduler := chrono.NewDefaultTaskScheduler()

task, err := taskScheduler.ScheduleAtFixedRate(func(ctx context.Context) {
	log.Print("Fixed Rate of 5 seconds")
}, 5 * time.Second)

if err == nil {
	log.Print("Task has been scheduled successfully.")
}
```

The next task will run always after 5 seconds no matter the status of the previous task, which may be still running. So even if the previous task isn't done, the next task will run.
We can also use the **WithStartTime** option to specify the desired first execution time of the task.

```go
now := time.Now()

task, err := taskScheduler.ScheduleAtFixedRate(func(ctx context.Context) {
	log.Print("Fixed Rate of 5 seconds")
}, 5 * time.Second, chrono.WithStartTime(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second() + 2))
```

When we use this option, the task will run at the specified execution time and subsequently with the given period. In the above example, the task will first be executed 2 seconds after the current time.

We can also combine this option with **WithLocation** based on our requirements.

```go
now := time.Now()

task, err := taskScheduler.ScheduleAtFixedRate(func(ctx context.Context) {
	log.Print("Fixed Rate of 5 seconds")
}, 5 * time.Second, chrono.WithStartTime(now.Year(), now.Month(), now.Day(), 18, 45, 0),
chrono.WithLocation("America/New_York"))
```

In the above example, the task will first be executed at 18:45 of the current date in America/New York time.
**If the start time is in the past, the task will be executed immediately.**

## Scheduling a Task using Cron Expression
Sometimes Fixed Rate and Fixed Delay can not fulfill your needs, and we need the flexibility of cron expressions to schedule the execution of your tasks. With the help of the provided **ScheduleWithCron method**, we can schedule a task based on a cron expression.

```go
taskScheduler := chrono.NewDefaultTaskScheduler()

task, err := taskScheduler.ScheduleWithCron(func(ctx context.Context) {
	log.Print("Scheduled Task With Cron")
}, "0 45 18 10 * *")

if err == nil {
	log.Print("Task has been scheduled")
}
```

In this case, we're scheduling a task to be executed at 18:45  on the 10th day of every month

By default, the local time is used for the cron expression. However, we can use the **WithLocation** option to change this.

```go
task, err := taskScheduler.ScheduleWithCron(func(ctx context.Context) {
	log.Print("Scheduled Task With Cron")
}, "0 45 18 10 * *", chrono.WithLocation("America/New_York"))
```

In the above example, Task will be scheduled to be executed at 18:45 on the 10th day of every month in America/New York time.

**WithStartTimeoption** cannot be used with **ScheduleWithCron**.

## Canceling a Scheduled Task
Schedule methods return an instance of type ScheduledTask, which allows us to cancel a task or to check if the task is canceled. The Cancel method cancels the scheduled task but running tasks won't be interrupted.


```go
taskScheduler := chrono.NewDefaultTaskScheduler()

task, err := taskScheduler.ScheduleAtFixedRate(func(ctx context.Context) {
	log.Print("Fixed Rate of 5 seconds")
}, 5 * time.Second)

/* ... */
	
task.Cancel()
```

## Shutting Down a Scheduler
The **Shutdown()** method doesn't cause immediate shut down of the Scheduler and returns a channel. It will make the Scheduler stop accepting new tasks and shut down after all running tasks finish their current work.


```go
taskScheduler := chrono.NewDefaultTaskScheduler()

/* ... */

shutdownChannel := taskScheduler.Shutdown()
<- shutdownChannel
	
/* after all running task finished their works */
```

Stargazers
-----------
[![Stargazers repo roster for @procyon-projects/chrono](https://reporoster.com/stars/procyon-projects/chrono)](https://codnect.io/chrono/stargazers)

Forkers
-----------
[![Forkers repo roster for @procyon-projects/chrono](https://reporoster.com/forks/procyon-projects/chrono)](https://codnect.io/chrono/network/members)

# License
Chrono is released under MIT License.


---
context/examples/chrono-src/cron.go
---
package chrono

import (
	"errors"
	"fmt"
	"math"
	"math/bits"
	"strconv"
	"strings"
	"time"
)

var (
	months = []string{"JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"}
	days   = []string{"MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"}
)

type cronField string

const (
	cronFieldNanoSecond = "NANO_SECOND"
	cronFieldSecond     = "SECOND"
	cronFieldMinute     = "MINUTE"
	cronFieldHour       = "HOUR"
	cronFieldDayOfMonth = "DAY_OF_MONTH"
	cronFieldMonth      = "MONTH"
	cronFieldDayOfWeek  = "DAY_OF_WEEK"
)

type fieldType struct {
	Field    cronField
	MinValue int
	MaxValue int
}

var (
	nanoSecond = fieldType{cronFieldNanoSecond, 0, 999999999}
	second     = fieldType{cronFieldSecond, 0, 59}
	minute     = fieldType{cronFieldMinute, 0, 59}
	hour       = fieldType{cronFieldHour, 0, 23}
	dayOfMonth = fieldType{cronFieldDayOfMonth, 1, 31}
	month      = fieldType{cronFieldMonth, 1, 12}
	dayOfWeek  = fieldType{cronFieldDayOfWeek, 1, 7}
)

var cronFieldTypes = []fieldType{
	second,
	minute,
	hour,
	dayOfMonth,
	month,
	dayOfWeek,
}

type valueRange struct {
	MinValue int
	MaxValue int
}

func newValueRange(min int, max int) valueRange {
	return valueRange{
		MinValue: min,
		MaxValue: max,
	}
}

type cronFieldBits struct {
	Typ  fieldType
	Bits uint64
}

func newFieldBits(typ fieldType) *cronFieldBits {
	return &cronFieldBits{
		Typ: typ,
	}
}

const maxAttempts = 366
const mask = 0xFFFFFFFFFFFFFFFF

type CronExpression struct {
	fields []*cronFieldBits
}

func newCronExpression() *CronExpression {
	exp := &CronExpression{
		make([]*cronFieldBits, 0),
	}

	nanoSecondBits := newFieldBits(nanoSecond)
	nanoSecondBits.Bits = 1

	exp.fields = append(exp.fields, nanoSecondBits)
	return exp
}

func (expression *CronExpression) NextTime(t time.Time) time.Time {

	t = t.Add(1 * time.Nanosecond)

	for i := 0; i < maxAttempts; i++ {
		result := expression.next(t)

		if result.IsZero() || result.Equal(t) {
			return result
		}

		t = result
	}

	return time.Time{}
}

func (expression *CronExpression) next(t time.Time) time.Time {
	for _, field := range expression.fields {
		t = expression.nextField(field, t)

		if t.IsZero() {
			return t
		}
	}

	return t
}

func (expression *CronExpression) nextField(field *cronFieldBits, t time.Time) time.Time {
	current := getTimeValue(t, field.Typ.Field)
	next := setNextBit(field.Bits, current)

	if next == -1 {
		amount := getFieldMaxValue(t, field.Typ) - current + 1
		t = addTime(t, field.Typ.Field, amount)
		next = setNextBit(field.Bits, 0)
	}

	if next == current {
		return t
	} else {
		count := 0
		current := getTimeValue(t, field.Typ.Field)
		for ; current != next && count < maxAttempts; count++ {
			t = elapseUntil(t, field.Typ, next)
			current = getTimeValue(t, field.Typ.Field)
		}

		if count >= maxAttempts {
			return time.Time{}
		}

		return t
	}
}

func ParseCronExpression(expression string) (*CronExpression, error) {
	if len(expression) == 0 {
		return nil, errors.New("cron expression must not be empty")
	}

	fields := strings.Fields(expression)

	if len(fields) != 6 {
		return nil, fmt.Errorf("cron expression must consist of 6 fields : found %d in \"%s\"", len(fields), expression)
	}

	cronExpression := newCronExpression()

	for index, cronFieldType := range cronFieldTypes {
		value, err := parseField(fields[index], cronFieldType)

		if err != nil {
			return nil, err
		}

		if cronFieldType.Field == cronFieldDayOfWeek && value.Bits&1<<0 != 0 {
			value.Bits |= 1 << 7
			temp := ^(1 << 0)
			value.Bits &= uint64(temp)
		}

		cronExpression.fields = append(cronExpression.fields, value)
	}

	return cronExpression, nil
}

func parseField(value string, fieldType fieldType) (*cronFieldBits, error) {
	if len(value) == 0 {
		return nil, fmt.Errorf("value must not be empty")
	}

	if fieldType.Field == cronFieldMonth {
		value = replaceOrdinals(value, months)
	} else if fieldType.Field == cronFieldDayOfWeek {
		value = replaceOrdinals(value, days)
	}

	cronFieldBits := newFieldBits(fieldType)

	fields := strings.Split(value, ",")

	for _, field := range fields {
		slashPos := strings.Index(field, "/")

		step := -1
		var valueRange valueRange

		if slashPos != -1 {
			rangeStr := field[0:slashPos]

			var err error
			valueRange, err = parseRange(rangeStr, fieldType)

			if err != nil {
				return nil, err
			}

			if strings.Index(rangeStr, "-") == -1 {
				valueRange = newValueRange(valueRange.MinValue, fieldType.MaxValue)
			}

			stepStr := field[slashPos+1:]

			step, err = strconv.Atoi(stepStr)

			if err != nil {
				return nil, fmt.Errorf("step must be number : \"%s\"", stepStr)
			}

			if step <= 0 {
				return nil, fmt.Errorf("step must be 1 or higher in \"%s\"", value)
			}

		} else {
			var err error
			valueRange, err = parseRange(field, fieldType)

			if err != nil {
				return nil, err
			}
		}

		if step > 1 {
			for index := valueRange.MinValue; index <= valueRange.MaxValue; index += step {
				cronFieldBits.Bits |= 1 << index
			}
			continue
		}

		if valueRange.MinValue == valueRange.MaxValue {
			cronFieldBits.Bits |= 1 << valueRange.MinValue
		} else {
			cronFieldBits.Bits |= ^(math.MaxUint64 << (valueRange.MaxValue + 1)) & (math.MaxUint64 << valueRange.MinValue)
		}
	}

	return cronFieldBits, nil
}

func parseRange(value string, fieldType fieldType) (valueRange, error) {
	if value == "*" {
		return newValueRange(fieldType.MinValue, fieldType.MaxValue), nil
	} else {
		hyphenPos := strings.Index(value, "-")

		if hyphenPos == -1 {
			result, err := checkValidValue(value, fieldType)

			if err != nil {
				return valueRange{}, err
			}

			return newValueRange(result, result), nil
		} else {
			maxStr := value[hyphenPos+1:]
			minStr := value[0:hyphenPos]

			min, err := checkValidValue(minStr, fieldType)

			if err != nil {
				return valueRange{}, err
			}
			var max int
			max, err = checkValidValue(maxStr, fieldType)

			if err != nil {
				return valueRange{}, err
			}

			if fieldType.Field == cronFieldDayOfWeek && min == 7 {
				min = 0
			}

			return newValueRange(min, max), nil
		}
	}
}

func replaceOrdinals(value string, list []string) string {
	value = strings.ToUpper(value)

	for index := 0; index < len(list); index++ {
		replacement := strconv.Itoa(index + 1)
		value = strings.ReplaceAll(value, list[index], replacement)
	}

	return value
}

func checkValidValue(value string, fieldType fieldType) (int, error) {
	result, err := strconv.Atoi(value)

	if err != nil {
		return 0, fmt.Errorf("the value in field %s must be number : %s", fieldType.Field, value)
	}

	if fieldType.Field == cronFieldDayOfWeek && result == 0 {
		return result, nil
	}

	if result >= fieldType.MinValue && result <= fieldType.MaxValue {
		return result, nil
	}

	return 0, fmt.Errorf("the value in field %s must be between %d and %d", fieldType.Field, fieldType.MinValue, fieldType.MaxValue)
}

func getTimeValue(t time.Time, field cronField) int {

	switch field {
	case cronFieldNanoSecond:
		return t.Nanosecond()
	case cronFieldSecond:
		return t.Second()
	case cronFieldMinute:
		return t.Minute()
	case cronFieldHour:
		return t.Hour()
	case cronFieldDayOfMonth:
		return t.Day()
	case cronFieldMonth:
		return int(t.Month())
	case cronFieldDayOfWeek:
		if t.Weekday() == 0 {
			return 7
		}
		return int(t.Weekday())
	}

	panic("unreachable code!")
}

func addTime(t time.Time, field cronField, value int) time.Time {
	switch field {
	case cronFieldNanoSecond:
		return t.Add(time.Duration(value) * time.Nanosecond)
	case cronFieldSecond:
		return t.Add(time.Duration(value) * time.Second)
	case cronFieldMinute:
		return t.Add(time.Duration(value) * time.Minute)
	case cronFieldHour:
		return t.Add(time.Duration(value) * time.Hour)
	case cronFieldDayOfMonth:
		return t.AddDate(0, 0, value)
	case cronFieldMonth:
		return t.AddDate(0, value, 0)
	case cronFieldDayOfWeek:
		return t.AddDate(0, 0, value)
	}

	panic("unreachable code!")
}

func setNextBit(bitsValue uint64, index int) int {
	result := bitsValue & (mask << index)

	if result != 0 {
		return bits.TrailingZeros64(result)
	}

	return -1
}

func elapseUntil(t time.Time, fieldType fieldType, value int) time.Time {
	current := getTimeValue(t, fieldType.Field)

	maxValue := getFieldMaxValue(t, fieldType)

	if current >= value {
		amount := value + maxValue - current + 1 - fieldType.MinValue
		return addTime(t, fieldType.Field, amount)
	}

	if value >= fieldType.MinValue && value <= maxValue {
		return with(t, fieldType.Field, value)
	}

	return addTime(t, fieldType.Field, value-current)
}

func with(t time.Time, field cronField, value int) time.Time {
	switch field {
	case cronFieldNanoSecond:
		return time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), value, time.Local)
	case cronFieldSecond:
		return time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), value, t.Nanosecond(), time.Local)
	case cronFieldMinute:
		return time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), value, t.Second(), t.Nanosecond(), time.Local)
	case cronFieldHour:
		return time.Date(t.Year(), t.Month(), t.Day(), value, t.Minute(), t.Second(), t.Nanosecond(), time.Local)
	case cronFieldDayOfMonth:
		return time.Date(t.Year(), t.Month(), value, t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), time.Local)
	case cronFieldMonth:
		return time.Date(t.Year(), time.Month(value), t.Day(), t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), time.Local)
	case cronFieldDayOfWeek:
		return t.AddDate(0, 0, value-int(t.Weekday()))
	}

	panic("unreachable code!")
}

func getFieldMaxValue(t time.Time, fieldType fieldType) int {

	if cronFieldDayOfMonth == fieldType.Field {
		switch int(t.Month()) {
		case 2:
			if isLeapYear(t.Year()) {
				return 29
			}
			return 28
		case 4:
			return 30
		case 6:
			return 30
		case 9:
			return 30
		case 11:
			return 30
		default:
			return 31
		}
	}

	return fieldType.MaxValue
}

func isLeapYear(year int) bool {
	return year%400 == 0 || year%100 != 0 && year%4 == 0
}


---
context/examples/chrono-src/cron_test.go
---
package chrono

import (
	"github.com/stretchr/testify/assert"
	"testing"
	"time"
)

const timeLayout = "2006-01-02 15:04:05"

func TestCronExpression_NextTime(t *testing.T) {
	testCases := []struct {
		expression string
		time       string
		nextTimes  []string
	}{
		{
			"* * * * * *",
			"2021-05-31 23:59:56",
			[]string{
				"2021-05-31 23:59:57",
				"2021-05-31 23:59:58",
				"2021-05-31 23:59:59",
				"2021-06-01 00:00:00",
				"2021-06-01 00:00:01",
				"2021-06-01 00:00:02",
			},
		},
		{
			"17/3 * * * * *",
			"2021-03-16 15:04:16",
			[]string{
				"2021-03-16 15:04:17",
				"2021-03-16 15:04:20",
				"2021-03-16 15:04:23",
				"2021-03-16 15:04:26",
				"2021-03-16 15:04:29",
				"2021-03-16 15:04:32",
			},
		},
		{
			"19/3 * * * * *",
			"2021-03-16 15:04:19",
			[]string{
				"2021-03-16 15:04:22",
				"2021-03-16 15:04:25",
				"2021-03-16 15:04:28",
				"2021-03-16 15:04:31",
				"2021-03-16 15:04:34",
				"2021-03-16 15:04:37",
			},
		},
		{
			"8-19/3 * * * * *",
			"2021-03-16 15:04:23",
			[]string{
				"2021-03-16 15:05:08",
				"2021-03-16 15:05:11",
				"2021-03-16 15:05:14",
				"2021-03-16 15:05:17",
				"2021-03-16 15:06:08",
				"2021-03-16 15:06:11",
			},
		},
		{
			"8-24 * * * * *",
			"2021-03-16 15:04:23",
			[]string{
				"2021-03-16 15:04:24",
				"2021-03-16 15:05:08",
				"2021-03-16 15:05:09",
				"2021-03-16 15:05:10",
				"2021-03-16 15:05:11",
				"2021-03-16 15:05:12",
			},
		},
		{
			"0 * * * * *",
			"2021-05-21 13:41:37",
			[]string{
				"2021-05-21 13:42:00",
				"2021-05-21 13:43:00",
				"2021-05-21 13:44:00",
				"2021-05-21 13:45:00",
				"2021-05-21 13:46:00",
				"2021-05-21 13:47:00",
			},
		},
		{
			"7 * * * * *",
			"2021-05-22 13:12:56",
			[]string{
				"2021-05-22 13:13:07",
				"2021-05-22 13:14:07",
				"2021-05-22 13:15:07",
				"2021-05-22 13:16:07",
				"2021-05-22 13:17:07",
				"2021-05-22 13:18:07",
			},
		},
		{
			"0 0 * * * *",
			"2021-05-21 13:41:37",
			[]string{
				"2021-05-21 14:00:00",
				"2021-05-21 15:00:00",
				"2021-05-21 16:00:00",
				"2021-05-21 17:00:00",
				"2021-05-21 18:00:00",
				"2021-05-21 19:00:00",
			},
		},
		{
			"18 15 * * * *",
			"2021-05-21 19:12:56",
			[]string{
				"2021-05-21 19:15:18",
				"2021-05-21 20:15:18",
				"2021-05-21 21:15:18",
				"2021-05-21 22:15:18",
				"2021-05-21 23:15:18",
				"2021-05-22 00:15:18",
			},
		},
		{
			"18 15/5 * * * *",
			"2021-05-21 19:43:56",
			[]string{
				"2021-05-21 19:45:18",
				"2021-05-21 19:50:18",
				"2021-05-21 19:55:18",
				"2021-05-21 20:15:18",
				"2021-05-21 20:20:18",
				"2021-05-21 20:25:18",
			},
		},
		{
			"18 15-30/5 * * * *",
			"2021-05-21 19:43:56",
			[]string{
				"2021-05-21 20:15:18",
				"2021-05-21 20:20:18",
				"2021-05-21 20:25:18",
				"2021-05-21 20:30:18",
				"2021-05-21 21:15:18",
				"2021-05-21 21:20:18",
			},
		},
		{
			"18 40-45 * * * *",
			"2021-05-21 19:43:56",
			[]string{
				"2021-05-21 19:44:18",
				"2021-05-21 19:45:18",
				"2021-05-21 20:40:18",
				"2021-05-21 20:41:18",
				"2021-05-21 20:42:18",
				"2021-05-21 20:43:18",
			},
		},
		{
			"0 0 0 * * *",
			"2020-02-27 13:41:37",
			[]string{
				"2020-02-28 00:00:00",
				"2020-02-29 00:00:00",
				"2020-03-01 00:00:00",
				"2020-03-02 00:00:00",
				"2020-03-03 00:00:00",
				"2020-03-04 00:00:00",
			},
		},
		{
			"45 13 14 * * *",
			"2020-12-28 13:41:37",
			[]string{
				"2020-12-28 14:13:45",
				"2020-12-29 14:13:45",
				"2020-12-30 14:13:45",
				"2020-12-31 14:13:45",
				"2021-01-01 14:13:45",
				"2021-01-02 14:13:45",
			},
		},
		{
			"45 13 14/3 * * *",
			"2020-12-28 13:41:37",
			[]string{
				"2020-12-28 14:13:45",
				"2020-12-28 17:13:45",
				"2020-12-28 20:13:45",
				"2020-12-28 23:13:45",
				"2020-12-29 14:13:45",
				"2020-12-29 17:13:45",
			},
		},
		{
			"45 13 9-16/3 * * *",
			"2020-12-28 13:41:37",
			[]string{
				"2020-12-28 15:13:45",
				"2020-12-29 09:13:45",
				"2020-12-29 12:13:45",
				"2020-12-29 15:13:45",
				"2020-12-30 09:13:45",
				"2020-12-30 12:13:45",
			},
		},
		{
			"45 13 9-16 * * *",
			"2020-12-28 13:41:37",
			[]string{
				"2020-12-28 14:13:45",
				"2020-12-28 15:13:45",
				"2020-12-28 16:13:45",
				"2020-12-29 09:13:45",
				"2020-12-29 10:13:45",
				"2020-12-29 11:13:45",
			},
		},
		{
			"20 45 18 6 * *",
			"2020-03-27 13:41:37",
			[]string{
				"2020-04-06 18:45:20",
				"2020-05-06 18:45:20",
				"2020-06-06 18:45:20",
				"2020-07-06 18:45:20",
				"2020-08-06 18:45:20",
				"2020-09-06 18:45:20",
			},
		},
		{
			"20 45 18 10-12 * *",
			"2020-03-27 13:41:37",
			[]string{
				"2020-04-10 18:45:20",
				"2020-04-11 18:45:20",
				"2020-04-12 18:45:20",
				"2020-05-10 18:45:20",
				"2020-05-11 18:45:20",
				"2020-05-12 18:45:20",
			},
		},
		{
			"20 45 18 5-20/3 * *",
			"2020-03-27 13:41:37",
			[]string{
				"2020-04-05 18:45:20",
				"2020-04-08 18:45:20",
				"2020-04-11 18:45:20",
				"2020-04-14 18:45:20",
				"2020-04-17 18:45:20",
				"2020-04-20 18:45:20",
			},
		},
		{
			"0 0 0 1 * *",
			"2020-03-27 13:41:37",
			[]string{
				"2020-04-01 00:00:00",
				"2020-05-01 00:00:00",
				"2020-06-01 00:00:00",
				"2020-07-01 00:00:00",
				"2020-08-01 00:00:00",
				"2020-09-01 00:00:00",
			},
		},
		{
			"0 0 0 1 1 *",
			"2020-03-27 13:41:37",
			[]string{
				"2021-01-01 00:00:00",
				"2022-01-01 00:00:00",
				"2023-01-01 00:00:00",
				"2024-01-01 00:00:00",
				"2025-01-01 00:00:00",
				"2026-01-01 00:00:00",
			},
		},
		{
			"0 0 0 1 6 *",
			"2020-03-27 13:41:37",
			[]string{
				"2020-06-01 00:00:00",
				"2021-06-01 00:00:00",
				"2022-06-01 00:00:00",
				"2023-06-01 00:00:00",
				"2024-06-01 00:00:00",
				"2025-06-01 00:00:00",
			},
		},
		{
			"0 0 0 1 3-12 *",
			"2020-03-27 13:41:37",
			[]string{
				"2020-04-01 00:00:00",
				"2020-05-01 00:00:00",
				"2020-06-01 00:00:00",
				"2020-07-01 00:00:00",
				"2020-08-01 00:00:00",
				"2020-09-01 00:00:00",
			},
		},
		{
			"0 0 0 1 3-12/3 *",
			"2020-03-27 13:41:37",
			[]string{
				"2020-06-01 00:00:00",
				"2020-09-01 00:00:00",
				"2020-12-01 00:00:00",
				"2021-03-01 00:00:00",
				"2021-06-01 00:00:00",
				"2021-09-01 00:00:00",
			},
		},
		{
			"0 0 0 1 SEP *",
			"2020-03-27 13:41:37",
			[]string{
				"2020-09-01 00:00:00",
				"2021-09-01 00:00:00",
				"2022-09-01 00:00:00",
				"2023-09-01 00:00:00",
				"2024-09-01 00:00:00",
				"2025-09-01 00:00:00",
			},
		},
		{
			"0 0 0 1 AUG-OCT *",
			"2020-03-27 13:41:37",
			[]string{
				"2020-08-01 00:00:00",
				"2020-09-01 00:00:00",
				"2020-10-01 00:00:00",
				"2021-08-01 00:00:00",
				"2021-09-01 00:00:00",
				"2021-10-01 00:00:00",
			},
		},
		{
			"0 0 0 1 5 0",
			"2021-05-23 13:41:37",
			[]string{
				"2022-05-01 00:00:00",
				"2033-05-01 00:00:00",
				"2039-05-01 00:00:00",
				"2044-05-01 00:00:00",
				"2050-05-01 00:00:00",
				"2061-05-01 00:00:00",
			},
		},
		{
			"0 0 0 1 5 0",
			"2021-05-23 13:41:37",
			[]string{
				"2022-05-01 00:00:00",
				"2033-05-01 00:00:00",
				"2039-05-01 00:00:00",
				"2044-05-01 00:00:00",
				"2050-05-01 00:00:00",
				"2061-05-01 00:00:00",
			},
		},
		{
			"0 0 0 1 5 SUN",
			"2021-05-23 13:41:37",
			[]string{
				"2022-05-01 00:00:00",
				"2033-05-01 00:00:00",
				"2039-05-01 00:00:00",
				"2044-05-01 00:00:00",
				"2050-05-01 00:00:00",
				"2061-05-01 00:00:00",
			},
		},
		{
			"0 0 0 1 5 MON",
			"2021-05-23 13:41:37",
			[]string{
				"2023-05-01 00:00:00",
				"2028-05-01 00:00:00",
				"2034-05-01 00:00:00",
				"2045-05-01 00:00:00",
				"2051-05-01 00:00:00",
				"2056-05-01 00:00:00",
			},
		},
		{
			"12 15 13 * * THU-SAT",
			"2021-05-23 13:41:37",
			[]string{
				"2021-05-27 13:15:12",
				"2021-05-28 13:15:12",
				"2021-05-29 13:15:12",
				"2021-06-03 13:15:12",
				"2021-06-04 13:15:12",
				"2021-06-05 13:15:12",
			},
		},
		{
			"12 15 13 * * 4-6",
			"2021-05-23 13:41:37",
			[]string{
				"2021-05-27 13:15:12",
				"2021-05-28 13:15:12",
				"2021-05-29 13:15:12",
				"2021-06-03 13:15:12",
				"2021-06-04 13:15:12",
				"2021-06-05 13:15:12",
			},
		},
		{
			"13-15,46-49 * * * * *",
			"2021-05-21 13:18:14",
			[]string{
				"2021-05-21 13:18:15",
				"2021-05-21 13:18:46",
				"2021-05-21 13:18:47",
				"2021-05-21 13:18:48",
				"2021-05-21 13:18:49",
				"2021-05-21 13:19:13",
			},
		},
		{
			"17-31/5,50-57/4 * * * * *",
			"2021-05-21 13:18:14",
			[]string{
				"2021-05-21 13:18:17",
				"2021-05-21 13:18:22",
				"2021-05-21 13:18:27",
				"2021-05-21 13:18:50",
				"2021-05-21 13:18:54",
				"2021-05-21 13:19:17",
			},
		},
		{
			"17 7-9,54-55 * * * *",
			"2021-05-21 13:02:17",
			[]string{
				"2021-05-21 13:07:17",
				"2021-05-21 13:08:17",
				"2021-05-21 13:09:17",
				"2021-05-21 13:54:17",
				"2021-05-21 13:55:17",
				"2021-05-21 14:07:17",
			},
		},
		{
			"17 8-16/4,50-55/3 * * * *",
			"2021-05-21 13:02:17",
			[]string{
				"2021-05-21 13:08:17",
				"2021-05-21 13:12:17",
				"2021-05-21 13:16:17",
				"2021-05-21 13:50:17",
				"2021-05-21 13:53:17",
				"2021-05-21 14:08:17",
			},
		},
		{
			"17 4 5-9,17-19 * * *",
			"2021-05-21 08:02:17",
			[]string{
				"2021-05-21 08:04:17",
				"2021-05-21 09:04:17",
				"2021-05-21 17:04:17",
				"2021-05-21 18:04:17",
				"2021-05-21 19:04:17",
				"2021-05-22 05:04:17",
			},
		},
		{
			"17 4 5-9/2,16-23/3 * * *",
			"2021-05-21 08:02:17",
			[]string{
				"2021-05-21 09:04:17",
				"2021-05-21 16:04:17",
				"2021-05-21 19:04:17",
				"2021-05-21 22:04:17",
				"2021-05-22 05:04:17",
				"2021-05-22 07:04:17",
			},
		},
		{
			"17 4 17 13-15,26-27 * *",
			"2021-05-14 08:02:17",
			[]string{
				"2021-05-14 17:04:17",
				"2021-05-15 17:04:17",
				"2021-05-26 17:04:17",
				"2021-05-27 17:04:17",
				"2021-06-13 17:04:17",
				"2021-06-14 17:04:17",
			},
		},
		{
			"17 4 17 7-15/4,22-29/3 * *",
			"2021-05-13 08:02:17",
			[]string{
				"2021-05-15 17:04:17",
				"2021-05-22 17:04:17",
				"2021-05-25 17:04:17",
				"2021-05-28 17:04:17",
				"2021-06-07 17:04:17",
				"2021-06-11 17:04:17",
			},
		},
		{
			"17 4 17 16 1-3,11-12 *",
			"2021-02-13 08:02:17",
			[]string{
				"2021-02-16 17:04:17",
				"2021-03-16 17:04:17",
				"2021-11-16 17:04:17",
				"2021-12-16 17:04:17",
				"2022-01-16 17:04:17",
				"2022-02-16 17:04:17",
			},
		},
		{
			"17 4 17 16 JAN-MAR,NOV-DEC *",
			"2021-02-13 08:02:17",
			[]string{
				"2021-02-16 17:04:17",
				"2021-03-16 17:04:17",
				"2021-11-16 17:04:17",
				"2021-12-16 17:04:17",
				"2022-01-16 17:04:17",
				"2022-02-16 17:04:17",
			},
		},
		{
			"17 4 17 16 4-10/3,8-12/2 *",
			"2021-02-13 08:02:17",
			[]string{
				"2021-04-16 17:04:17",
				"2021-07-16 17:04:17",
				"2021-08-16 17:04:17",
				"2021-10-16 17:04:17",
				"2021-12-16 17:04:17",
				"2022-04-16 17:04:17",
			},
		},
		{
			"17 4 17 16 APR-OCT/3,AUG-DEC/2 *",
			"2021-02-13 08:02:17",
			[]string{
				"2021-04-16 17:04:17",
				"2021-07-16 17:04:17",
				"2021-08-16 17:04:17",
				"2021-10-16 17:04:17",
				"2021-12-16 17:04:17",
				"2022-04-16 17:04:17",
			},
		},
		{
			"17 4 17 16 5 MON-SUN/3",
			"2021-02-13 08:02:17",
			[]string{
				"2021-05-16 17:04:17",
				"2022-05-16 17:04:17",
				"2024-05-16 17:04:17",
				"2027-05-16 17:04:17",
				"2030-05-16 17:04:17",
				"2032-05-16 17:04:17",
			},
		},
		{
			"17 4 17 16 5 MON-TUE,FRI-SAT",
			"2021-02-13 08:02:17",
			[]string{
				"2022-05-16 17:04:17",
				"2023-05-16 17:04:17",
				"2025-05-16 17:04:17",
				"2026-05-16 17:04:17",
				"2028-05-16 17:04:17",
				"2031-05-16 17:04:17",
			},
		},
		{
			"17 4 17 16 5 MON-THU/2,FRI-SUN/2",
			"2021-02-13 08:02:17",
			[]string{
				"2021-05-16 17:04:17",
				"2022-05-16 17:04:17",
				"2025-05-16 17:04:17",
				"2027-05-16 17:04:17",
				"2029-05-16 17:04:17",
				"2031-05-16 17:04:17",
			},
		},
	}

	for _, testCase := range testCases {
		exp, err := ParseCronExpression(testCase.expression)

		if err != nil {
			t.Errorf("could not parse cron expression : %s", err.Error())
			return
		}

		date, err := time.Parse(timeLayout, testCase.time)

		if err != nil {
			t.Errorf("could not parse time : %s", testCase.time)
			return
		}

		for _, nextTimeStr := range testCase.nextTimes {
			nextTime, err := time.Parse(timeLayout, nextTimeStr)

			if err != nil {
				t.Errorf("could not parse next time : %s", nextTimeStr)
				return
			}

			date = exp.NextTime(date)

			if nextTime.Format(timeLayout) != date.Format(timeLayout) {
				t.Errorf("got: %s expected: %s", date, nextTime)
			}
		}
	}

}

func TestParseCronExpression_Errors(t *testing.T) {
	testCases := []struct {
		expression  string
		errorString string
	}{
		{expression: "", errorString: "cron expression must not be empty"},
		{expression: "test * * * * *", errorString: "the value in field SECOND must be number : test"},
		{expression: "5 * * * *", errorString: "cron expression must consist of 6 fields : found 5 in \"5 * * * *\""},
		{expression: "61 * * * * *", errorString: "the value in field SECOND must be between 0 and 59"},
		{expression: "61 * * * * *", errorString: "the value in field SECOND must be between 0 and 59"},
		{expression: "* 65 * * * *", errorString: "the value in field MINUTE must be between 0 and 59"},
		{expression: "* * * 0 * *", errorString: "the value in field DAY_OF_MONTH must be between 1 and 31"},
		{expression: "* * 1-12/0 * * *", errorString: "step must be 1 or higher in \"1-12/0\""},
		{expression: "* * 0-32/5 * * *", errorString: "the value in field HOUR must be between 0 and 23"},
		{expression: "* * * * 0-10/2 *", errorString: "the value in field MONTH must be between 1 and 12"},
		{expression: "* * 1-12/test * * *", errorString: "step must be number : \"test\""},
	}

	for _, testCase := range testCases {
		exp, err := ParseCronExpression(testCase.expression)
		assert.Nil(t, exp, "expression must have been parsed : %s", testCase.expression)
		assert.NotNil(t, err, "an error must have been occurred")
		assert.Equal(t, testCase.errorString, err.Error(),
			"error string must not match, expected : %s, actual :%s", testCase.errorString, err.Error())
	}
}

func TestParseField_WhenValueIsEmpty(t *testing.T) {
	result, err := parseField("", second)
	assert.Nil(t, result, "result must not have been returned")
	assert.NotNil(t, err, "an error must have been occurred")
	assert.Equal(t, "value must not be empty", err.Error())
}


---
context/examples/chrono-src/executor.go
---
package chrono

import (
	"context"
	"errors"
	"sync"
	"time"
)

type TaskExecutor interface {
	Schedule(task Task, delay time.Duration) (ScheduledTask, error)
	ScheduleWithFixedDelay(task Task, initialDelay time.Duration, delay time.Duration) (ScheduledTask, error)
	ScheduleAtFixedRate(task Task, initialDelay time.Duration, period time.Duration) (ScheduledTask, error)
	IsShutdown() bool
	Shutdown() chan bool
}

type SimpleTaskExecutor struct {
	nextSequence          int
	isShutdown            bool
	executorMu            sync.RWMutex
	timer                 *time.Timer
	taskWaitGroup         sync.WaitGroup
	taskQueue             ScheduledTaskQueue
	newTaskChannel        chan *ScheduledRunnableTask
	rescheduleTaskChannel chan *ScheduledRunnableTask
	taskRunner            TaskRunner
	shutdownChannel       chan chan bool
}

func NewDefaultTaskExecutor() TaskExecutor {
	return NewSimpleTaskExecutor(NewDefaultTaskRunner())
}

func NewSimpleTaskExecutor(runner TaskRunner) *SimpleTaskExecutor {
	if runner == nil {
		runner = NewDefaultTaskRunner()
	}

	executor := &SimpleTaskExecutor{
		timer:                 time.NewTimer(1 * time.Hour),
		taskQueue:             make(ScheduledTaskQueue, 0),
		newTaskChannel:        make(chan *ScheduledRunnableTask),
		rescheduleTaskChannel: make(chan *ScheduledRunnableTask),
		taskRunner:            runner,
		shutdownChannel:       make(chan chan bool),
	}

	executor.timer.Stop()

	go executor.run()

	return executor
}

func (executor *SimpleTaskExecutor) Schedule(task Task, delay time.Duration) (ScheduledTask, error) {
	if task == nil {
		return nil, errors.New("task cannot be nil")
	}

	executor.executorMu.Lock()

	if executor.isShutdown {
		executor.executorMu.Unlock()
		return nil, errors.New("no new task won't be accepted because executor is already shut down")
	}

	executor.nextSequence++
	scheduledTask, err := CreateScheduledRunnableTask(executor.nextSequence, task, executor.calculateTriggerTime(delay), 0, false)
	executor.executorMu.Unlock()

	if err != nil {
		return nil, err
	}

	executor.addNewTask(scheduledTask)

	return scheduledTask, nil
}

func (executor *SimpleTaskExecutor) ScheduleWithFixedDelay(task Task, initialDelay time.Duration, delay time.Duration) (ScheduledTask, error) {
	if task == nil {
		return nil, errors.New("task cannot be nil")
	}

	executor.executorMu.Lock()

	if executor.isShutdown {
		executor.executorMu.Unlock()
		return nil, errors.New("no new task won't be accepted because executor is already shut down")
	}

	executor.nextSequence++
	scheduledTask, err := CreateScheduledRunnableTask(executor.nextSequence, task, executor.calculateTriggerTime(initialDelay), delay, false)
	executor.executorMu.Unlock()

	if err != nil {
		return nil, err
	}

	executor.addNewTask(scheduledTask)

	return scheduledTask, nil
}

func (executor *SimpleTaskExecutor) ScheduleAtFixedRate(task Task, initialDelay time.Duration, period time.Duration) (ScheduledTask, error) {
	if task == nil {
		return nil, errors.New("task cannot be nil")
	}

	executor.executorMu.Lock()

	if executor.isShutdown {
		executor.executorMu.Unlock()
		return nil, errors.New("no new task won't be accepted because executor is already shut down")
	}

	executor.nextSequence++
	scheduledTask, err := CreateScheduledRunnableTask(executor.nextSequence, task, executor.calculateTriggerTime(initialDelay), period, true)
	executor.executorMu.Unlock()

	if err != nil {
		return nil, err
	}

	executor.addNewTask(scheduledTask)

	return scheduledTask, nil
}

func (executor *SimpleTaskExecutor) IsShutdown() bool {
	executor.executorMu.Lock()
	defer executor.executorMu.Unlock()
	return executor.isShutdown
}

func (executor *SimpleTaskExecutor) Shutdown() chan bool {
	executor.executorMu.Lock()
	defer executor.executorMu.Unlock()

	if executor.isShutdown {
		panic("executor is already shut down")
	}

	executor.isShutdown = true

	stoppedChan := make(chan bool)
	executor.shutdownChannel <- stoppedChan
	return stoppedChan
}

func (executor *SimpleTaskExecutor) calculateTriggerTime(delay time.Duration) time.Time {
	if delay < 0 {
		delay = 0
	}

	return time.Now().Add(delay)
}

func (executor *SimpleTaskExecutor) addNewTask(task *ScheduledRunnableTask) {
	executor.newTaskChannel <- task
}

func (executor *SimpleTaskExecutor) run() {

	for {
		executor.taskQueue.SorByTriggerTime()

		if len(executor.taskQueue) == 0 {
			executor.timer.Stop()
		} else {
			executor.timer.Reset(executor.taskQueue[0].getDelay())
		}

		for {
			select {
			case clock := <-executor.timer.C:
				executor.timer.Stop()

				taskIndex := -1
				for index, scheduledTask := range executor.taskQueue {

					if scheduledTask.triggerTime.After(clock) || scheduledTask.triggerTime.IsZero() {
						break
					}

					taskIndex = index

					if scheduledTask.IsCancelled() {
						continue
					}

					if scheduledTask.isPeriodic() && scheduledTask.isFixedRate() {
						scheduledTask.triggerTime = scheduledTask.triggerTime.Add(scheduledTask.period)
					}

					executor.startTask(scheduledTask)
				}

				executor.taskQueue = executor.taskQueue[taskIndex+1:]
			case newScheduledTask := <-executor.newTaskChannel:
				executor.timer.Stop()
				executor.taskQueue = append(executor.taskQueue, newScheduledTask)
			case rescheduledTask := <-executor.rescheduleTaskChannel:
				executor.timer.Stop()
				executor.taskQueue = append(executor.taskQueue, rescheduledTask)
			case stoppedChan := <-executor.shutdownChannel:
				executor.timer.Stop()
				executor.taskWaitGroup.Wait()
				stoppedChan <- true
				return
			}

			break
		}

	}

}

func (executor *SimpleTaskExecutor) startTask(scheduledRunnableTask *ScheduledRunnableTask) {
	executor.taskWaitGroup.Add(1)

	executor.taskRunner.Run(func(ctx context.Context) {
		defer func() {
			if executor.IsShutdown() {
				scheduledRunnableTask.Cancel()
				executor.taskWaitGroup.Done()
				return
			}

			executor.taskWaitGroup.Done()

			if !scheduledRunnableTask.isPeriodic() {
				scheduledRunnableTask.Cancel()
			} else {
				if !scheduledRunnableTask.isFixedRate() {
					scheduledRunnableTask.triggerTime = executor.calculateTriggerTime(scheduledRunnableTask.period)
					executor.rescheduleTaskChannel <- scheduledRunnableTask
				}
			}
		}()

		if scheduledRunnableTask.isPeriodic() && scheduledRunnableTask.isFixedRate() {
			executor.rescheduleTaskChannel <- scheduledRunnableTask
		}

		scheduledRunnableTask.task(ctx)
	})

}


---
context/examples/chrono-src/executor_test.go
---
package chrono

import (
	"context"
	"github.com/stretchr/testify/assert"
	"sync/atomic"
	"testing"
	"time"
)

func TestNewDefaultTaskExecutor(t *testing.T) {
	executor := NewDefaultTaskExecutor()

	var counter int32

	task, err := executor.Schedule(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
	}, 1*time.Second)

	assert.Nil(t, err)

	<-time.After(2 * time.Second)
	assert.True(t, task.IsCancelled(), "scheduled task must have been cancelled")
	assert.True(t, counter == 1,
		"number of scheduled task execution must be 1, actual: %d", counter)
}

func TestSimpleTaskExecutor_WithoutTaskRunner(t *testing.T) {
	executor := NewSimpleTaskExecutor(nil)

	var counter int32

	task, err := executor.Schedule(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
	}, 1*time.Second)

	assert.Nil(t, err)

	<-time.After(2 * time.Second)
	assert.True(t, task.IsCancelled(), "scheduled task must have been cancelled")
	assert.True(t, counter == 1,
		"number of scheduled task execution must be 1, actual: %d", counter)
}

func TestSimpleTaskExecutor_Schedule_OneShotTask(t *testing.T) {
	executor := NewSimpleTaskExecutor(NewDefaultTaskRunner())

	var counter int32

	task, err := executor.Schedule(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
	}, 1*time.Second)

	assert.Nil(t, err)

	<-time.After(2 * time.Second)
	assert.True(t, task.IsCancelled(), "scheduled task must have been cancelled")
	assert.True(t, counter == 1,
		"number of scheduled task execution must be 1, actual: %d", counter)
}

func TestSimpleTaskExecutor_ScheduleWithFixedDelay(t *testing.T) {
	executor := NewSimpleTaskExecutor(NewDefaultTaskRunner())

	var counter int32

	task, err := executor.ScheduleWithFixedDelay(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
		<-time.After(500 * time.Millisecond)
	}, 0, 200*time.Millisecond)

	assert.Nil(t, err)

	<-time.After(1*time.Second + 500*time.Millisecond)
	task.Cancel()
	assert.True(t, counter >= 1 && counter <= 3,
		"number of scheduled task execution must be between 1 and 3, actual: %d", counter)
}

func TestSimpleTaskExecutor_ScheduleWithFixedDelayWithInitialDelay(t *testing.T) {
	executor := NewSimpleTaskExecutor(NewDefaultTaskRunner())

	var counter int32

	task, err := executor.ScheduleWithFixedDelay(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
		<-time.After(500 * time.Millisecond)
	}, 1*time.Second, 200*time.Millisecond)

	assert.Nil(t, err)

	<-time.After(2*time.Second + 500*time.Millisecond)
	task.Cancel()
	assert.True(t, counter >= 1 && counter <= 3,
		"number of scheduled task execution must be between 1 and 3, actual: %d", counter)
}

func TestSimpleTaskExecutor_ScheduleAtFixedRate(t *testing.T) {
	executor := NewSimpleTaskExecutor(NewDefaultTaskRunner())

	var counter int32

	task, err := executor.ScheduleAtFixedRate(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
	}, 0, 200*time.Millisecond)

	assert.Nil(t, err)

	<-time.After(2*time.Second - 50*time.Millisecond)
	task.Cancel()
	assert.True(t, counter >= 1 && counter <= 10,
		"number of scheduled task execution must be between 5 and 10, actual: %d", counter)
}

func TestSimpleTaskExecutor_ScheduleAtFixedRateWithInitialDelay(t *testing.T) {
	executor := NewSimpleTaskExecutor(NewDefaultTaskRunner())

	var counter int32

	task, err := executor.ScheduleAtFixedRate(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
		<-time.After(500 * time.Millisecond)
	}, 1*time.Second, 200*time.Millisecond)

	assert.Nil(t, err)

	<-time.After(3*time.Second - 50*time.Millisecond)
	task.Cancel()
	assert.True(t, counter >= 5 && counter <= 10,
		"number of scheduled task execution must be between 5 and 10, actual: %d", counter)
}

func TestSimpleTaskExecutor_Shutdown(t *testing.T) {
	executor := NewSimpleTaskExecutor(NewDefaultTaskRunner())

	var counter int32

	executor.ScheduleAtFixedRate(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
		<-time.After(500 * time.Millisecond)
	}, 1*time.Second, 200*time.Millisecond)

	<-time.After(2 * time.Second)
	executor.Shutdown()

	expected := counter
	<-time.After(3 * time.Second)

	assert.True(t, executor.IsShutdown())
	assert.Equal(t, expected, counter,
		"after shutdown, previously scheduled tasks should not be rescheduled", counter)
}

func TestSimpleTaskExecutor_NoNewTaskShouldBeAccepted_AfterShutdown(t *testing.T) {
	executor := NewSimpleTaskExecutor(NewDefaultTaskRunner())
	executor.Shutdown()

	var err error
	_, err = executor.Schedule(func(ctx context.Context) {
	}, 1*time.Second)

	assert.NotNil(t, err)

	_, err = executor.ScheduleWithFixedDelay(func(ctx context.Context) {
	}, 1*time.Second, 1*time.Second)

	assert.NotNil(t, err)

	_, err = executor.ScheduleAtFixedRate(func(ctx context.Context) {
	}, 1*time.Second, 200*time.Millisecond)
	assert.NotNil(t, err)
}

func TestSimpleTaskExecutor_Schedule_MultiTasks(t *testing.T) {
	executor := NewSimpleTaskExecutor(NewDefaultTaskRunner())

	var task1Counter int32
	var task2Counter int32
	var task3Counter int32

	task1, err := executor.ScheduleAtFixedRate(func(ctx context.Context) {
		atomic.AddInt32(&task1Counter, 1)
		<-time.After(500 * time.Millisecond)
	}, 1*time.Second, 200*time.Millisecond)

	assert.Nil(t, err)

	task2, err := executor.ScheduleWithFixedDelay(func(ctx context.Context) {
		atomic.AddInt32(&task2Counter, 1)
		<-time.After(500 * time.Millisecond)
	}, 0, 200*time.Millisecond)

	assert.Nil(t, err)

	task3, err := executor.ScheduleAtFixedRate(func(ctx context.Context) {
		atomic.AddInt32(&task3Counter, 1)
	}, 0, 200*time.Millisecond)

	assert.Nil(t, err)

	<-time.After(2*time.Second - 50*time.Millisecond)

	task1.Cancel()
	task2.Cancel()
	task3.Cancel()

	assert.True(t, task1Counter >= 5 && task1Counter <= 10,
		"number of scheduled task 1 execution must be between 5 and 10, actual: %d", task1Counter)

	assert.True(t, task2Counter >= 1 && task2Counter <= 3,
		"number of scheduled task 2 execution must be between 1 and 3, actual: %d", task2Counter)

	assert.True(t, task3Counter >= 1 && task3Counter <= 10,
		"number of scheduled task execution must be between 5 and 10, actual: %d", task3Counter)
}

func TestSimpleTaskExecutor_ScheduleWithNilTask(t *testing.T) {
	executor := NewSimpleTaskExecutor(NewDefaultTaskRunner())

	var task ScheduledTask
	var err error

	task, err = executor.Schedule(nil, 1*time.Second)
	assert.Nil(t, task)
	assert.NotNil(t, err)

	task, err = executor.ScheduleWithFixedDelay(nil, 1*time.Second, 1*time.Second)
	assert.Nil(t, task)
	assert.NotNil(t, err)

	task, err = executor.ScheduleAtFixedRate(nil, 1*time.Second, 1*time.Second)
	assert.Nil(t, task)
	assert.NotNil(t, err)
}

func TestSimpleTaskExecutor_Shutdown_TerminatedExecutor(t *testing.T) {
	executor := NewSimpleTaskExecutor(NewDefaultTaskRunner())
	executor.Shutdown()

	assert.Panics(t, func() {
		executor.Shutdown()
	})
}


---
context/examples/chrono-src/go.mod
---
module codnect.io/chrono

go 1.13

require github.com/stretchr/testify v1.7.0


---
context/examples/chrono-src/go.sum
---
github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/objx v0.1.0 h1:4G4v2dO3VZwixGIRoQ5Lfboy6nUhCyYzaqnIAPPhYs4=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=


---
context/examples/chrono-src/runner.go
---
package chrono

import (
	"context"
)

type TaskRunner interface {
	Run(task Task)
}

type SimpleTaskRunner struct {
}

func NewDefaultTaskRunner() TaskRunner {
	return NewSimpleTaskRunner()
}

func NewSimpleTaskRunner() *SimpleTaskRunner {
	return &SimpleTaskRunner{}
}

func (runner *SimpleTaskRunner) Run(task Task) {
	go func() {
		task(context.Background())
	}()
}


---
context/examples/chrono-src/scheduler.go
---
package chrono

import (
	"time"
)

type TaskScheduler interface {
	Schedule(task Task, options ...Option) (ScheduledTask, error)
	ScheduleWithCron(task Task, expression string, options ...Option) (ScheduledTask, error)
	ScheduleWithFixedDelay(task Task, delay time.Duration, options ...Option) (ScheduledTask, error)
	ScheduleAtFixedRate(task Task, period time.Duration, options ...Option) (ScheduledTask, error)
	IsShutdown() bool
	Shutdown() chan bool
}

type SimpleTaskScheduler struct {
	taskExecutor TaskExecutor
}

func NewSimpleTaskScheduler(executor TaskExecutor) *SimpleTaskScheduler {

	if executor == nil {
		executor = NewDefaultTaskExecutor()
	}

	scheduler := &SimpleTaskScheduler{
		taskExecutor: executor,
	}

	return scheduler
}

func NewDefaultTaskScheduler() TaskScheduler {
	return NewSimpleTaskScheduler(NewDefaultTaskExecutor())
}

func (scheduler *SimpleTaskScheduler) Schedule(task Task, options ...Option) (ScheduledTask, error) {
	schedulerTask, err := CreateSchedulerTask(task, options...)

	if err != nil {
		return nil, err
	}

	return scheduler.taskExecutor.Schedule(task, schedulerTask.GetInitialDelay())
}

func (scheduler *SimpleTaskScheduler) ScheduleWithCron(task Task, expression string, options ...Option) (ScheduledTask, error) {
	var schedulerTask *SchedulerTask
	var err error

	schedulerTask, err = CreateSchedulerTask(task, options...)

	if err != nil {
		return nil, err
	}

	var cronTrigger *CronTrigger
	cronTrigger, err = CreateCronTrigger(expression, schedulerTask.location)

	if err != nil {
		return nil, err
	}

	var triggerTask *TriggerTask
	triggerTask, err = CreateTriggerTask(schedulerTask.task, scheduler.taskExecutor, cronTrigger)

	if err != nil {
		return nil, err
	}

	return triggerTask.Schedule()
}

func (scheduler *SimpleTaskScheduler) ScheduleWithFixedDelay(task Task, delay time.Duration, options ...Option) (ScheduledTask, error) {
	schedulerTask, err := CreateSchedulerTask(task, options...)

	if err != nil {
		return nil, err
	}

	return scheduler.taskExecutor.ScheduleWithFixedDelay(schedulerTask.task, schedulerTask.GetInitialDelay(), delay)
}

func (scheduler *SimpleTaskScheduler) ScheduleAtFixedRate(task Task, period time.Duration, options ...Option) (ScheduledTask, error) {
	schedulerTask, err := CreateSchedulerTask(task, options...)

	if err != nil {
		return nil, err
	}

	return scheduler.taskExecutor.ScheduleAtFixedRate(schedulerTask.task, schedulerTask.GetInitialDelay(), period)
}

func (scheduler *SimpleTaskScheduler) IsShutdown() bool {
	return scheduler.taskExecutor.IsShutdown()
}

func (scheduler *SimpleTaskScheduler) Shutdown() chan bool {
	return scheduler.taskExecutor.Shutdown()
}


---
context/examples/chrono-src/scheduler_test.go
---
package chrono

import (
	"context"
	"github.com/stretchr/testify/assert"
	"sync/atomic"
	"testing"
	"time"
)

func TestDefaultTaskScheduler(t *testing.T) {
	scheduler := NewDefaultTaskScheduler()

	var counter int32
	now := time.Now()

	task, err := scheduler.Schedule(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
	}, WithStartTime(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()+1))

	assert.Nil(t, err)

	<-time.After(2 * time.Second)
	assert.True(t, task.IsCancelled(), "scheduled task must have been cancelled")
	assert.True(t, counter == 1,
		"number of scheduled task execution must be 1, actual: %d", counter)
}

func TestDefaultTaskSchedulerWithTimeOption(t *testing.T) {
	scheduler := NewDefaultTaskScheduler()

	var counter int32
	now := time.Now()
	starTime := now.Add(time.Second * 1)

	task, err := scheduler.Schedule(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
	}, WithTime(starTime))

	assert.Nil(t, err)

	<-time.After(2 * time.Second)
	assert.True(t, task.IsCancelled(), "scheduled task must have been cancelled")
	assert.True(t, counter == 1,
		"number of scheduled task execution must be 1, actual: %d", counter)
}

func TestSimpleTaskScheduler_ScheduleWithoutTask(t *testing.T) {
	scheduler := NewDefaultTaskScheduler()
	task, err := scheduler.Schedule(nil)
	assert.Error(t, err)
	assert.Nil(t, task)
}

func TestSimpleTaskScheduler_ScheduleWithFixedDelayWithoutTask(t *testing.T) {
	scheduler := NewDefaultTaskScheduler()
	task, err := scheduler.ScheduleWithFixedDelay(nil, 2*time.Second)
	assert.Error(t, err)
	assert.Nil(t, task)
}

func TestSimpleTaskScheduler_ScheduleAtFixedRateWithoutTask(t *testing.T) {
	scheduler := NewDefaultTaskScheduler()
	task, err := scheduler.ScheduleAtFixedRate(nil, 2*time.Second)
	assert.Error(t, err)
	assert.Nil(t, task)
}

func TestSimpleTaskScheduler_ScheduleWithCronWithoutTask(t *testing.T) {
	scheduler := NewDefaultTaskScheduler()
	task, err := scheduler.ScheduleWithCron(nil, "* * * * * *")
	assert.Error(t, err)
	assert.Nil(t, task)
}

func TestSimpleTaskScheduler_ScheduleWithCronUsingInvalidCronExpresion(t *testing.T) {
	scheduler := NewDefaultTaskScheduler()
	task, err := scheduler.ScheduleWithCron(func(ctx context.Context) {

	}, "test * * * * *")
	assert.Error(t, err)
	assert.Nil(t, task)
}

func TestSimpleTaskScheduler_WithoutScheduledExecutor(t *testing.T) {
	scheduler := NewSimpleTaskScheduler(nil)

	var counter int32
	now := time.Now()

	task, err := scheduler.Schedule(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
	}, WithStartTime(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()+1))

	assert.Nil(t, err)

	<-time.After(2 * time.Second)
	assert.True(t, task.IsCancelled(), "scheduled task must have been cancelled")
	assert.True(t, counter == 1,
		"number of scheduled task execution must be 1, actual: %d", counter)
}

func TestSimpleTaskScheduler_WithoutScheduledExecutorWithTimeOption(t *testing.T) {
	scheduler := NewSimpleTaskScheduler(nil)

	var counter int32
	now := time.Now()
	startTime := now.Add(time.Second * 1)

	task, err := scheduler.Schedule(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
	}, WithTime(startTime))

	assert.Nil(t, err)

	<-time.After(2 * time.Second)
	assert.True(t, task.IsCancelled(), "scheduled task must have been cancelled")
	assert.True(t, counter == 1,
		"number of scheduled task execution must be 1, actual: %d", counter)
}

func TestSimpleTaskScheduler_ScheduleOneShotTaskWithStartTimeOption(t *testing.T) {
	scheduler := NewSimpleTaskScheduler(NewDefaultTaskExecutor())

	var counter int32
	now := time.Now()

	task, err := scheduler.Schedule(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
	}, WithStartTime(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()+1))

	assert.Nil(t, err)

	<-time.After(2 * time.Second)
	assert.True(t, task.IsCancelled(), "scheduled task must have been cancelled")
	assert.True(t, counter == 1,
		"number of scheduled task execution must be 1, actual: %d", counter)
}

func TestSimpleTaskScheduler_ScheduleOneShotTaskWithTimeOption(t *testing.T) {
	scheduler := NewSimpleTaskScheduler(NewDefaultTaskExecutor())

	var counter int32
	now := time.Now()
	startTime := now.Add(time.Second * 1)

	task, err := scheduler.Schedule(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
	}, WithTime(startTime))

	assert.Nil(t, err)

	<-time.After(2 * time.Second)
	assert.True(t, task.IsCancelled(), "scheduled task must have been cancelled")
	assert.True(t, counter == 1,
		"number of scheduled task execution must be 1, actual: %d", counter)
}

func TestSimpleTaskScheduler_ScheduleWithFixedDelay(t *testing.T) {
	scheduler := NewSimpleTaskScheduler(NewDefaultTaskExecutor())

	var counter int32

	task, err := scheduler.ScheduleWithFixedDelay(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
		<-time.After(500 * time.Millisecond)
	}, 200*time.Millisecond)

	assert.Nil(t, err)

	<-time.After(1*time.Second + 500*time.Millisecond)
	task.Cancel()
	assert.True(t, counter >= 1 && counter <= 3,
		"number of scheduled task execution must be between 1 and 3, actual: %d", counter)
}

func TestSimpleTaskScheduler_ScheduleWithFixedDelayWithStartTimeOption(t *testing.T) {
	scheduler := NewSimpleTaskScheduler(NewDefaultTaskExecutor())

	var counter int32
	now := time.Now()

	task, err := scheduler.ScheduleWithFixedDelay(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
		<-time.After(500 * time.Millisecond)
	}, 200*time.Millisecond, WithStartTime(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()+1))

	assert.Nil(t, err)

	<-time.After(2*time.Second + 500*time.Millisecond)
	task.Cancel()
	assert.True(t, counter >= 1 && counter <= 3,
		"number of scheduled task execution must be between 1 and 3, actual: %d", counter)
}

func TestSimpleTaskScheduler_ScheduleWithFixedDelayWithTimeOption(t *testing.T) {
	scheduler := NewSimpleTaskScheduler(NewDefaultTaskExecutor())

	var counter int32
	now := time.Now()
	startTime := now.Add(time.Second * 1)

	task, err := scheduler.ScheduleWithFixedDelay(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
		<-time.After(500 * time.Millisecond)
	}, 200*time.Millisecond, WithTime(startTime))

	assert.Nil(t, err)

	<-time.After(2*time.Second + 500*time.Millisecond)
	task.Cancel()
	assert.True(t, counter >= 1 && counter <= 3,
		"number of scheduled task execution must be between 1 and 3, actual: %d", counter)
}

func TestSimpleTaskScheduler_ScheduleAtFixedRate(t *testing.T) {
	scheduler := NewSimpleTaskScheduler(NewDefaultTaskExecutor())

	var counter int32

	task, err := scheduler.ScheduleAtFixedRate(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
	}, 200*time.Millisecond)

	assert.Nil(t, err)

	<-time.After(1*time.Second + 950*time.Microsecond)
	task.Cancel()
	assert.True(t, counter >= 1 && counter <= 10,
		"number of scheduled task execution must be between 5 and 10, actual: %d", counter)
}

func TestSimpleTaskScheduler_ScheduleAtFixedRateWithStartTimeOption(t *testing.T) {
	scheduler := NewSimpleTaskScheduler(NewDefaultTaskExecutor())

	var counter int32
	now := time.Now()

	task, err := scheduler.ScheduleAtFixedRate(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
		<-time.After(500 * time.Millisecond)
	}, 200*time.Millisecond, WithStartTime(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()+1))

	assert.Nil(t, err)

	<-time.After(3*time.Second - 50*time.Millisecond)
	task.Cancel()
	assert.True(t, counter >= 5 && counter <= 10,
		"number of scheduled task execution must be between 5 and 10, actual: %d", counter)
}

func TestSimpleTaskScheduler_ScheduleAtFixedRateWithTimeOption(t *testing.T) {
	scheduler := NewSimpleTaskScheduler(NewDefaultTaskExecutor())

	var counter int32
	now := time.Now()
	startTime := now.Add(time.Second * 1)

	task, err := scheduler.ScheduleAtFixedRate(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
		<-time.After(500 * time.Millisecond)
	}, 200*time.Millisecond, WithTime(startTime))

	assert.Nil(t, err)

	<-time.After(3*time.Second - 50*time.Millisecond)
	task.Cancel()
	assert.True(t, counter >= 5 && counter <= 10,
		"number of scheduled task execution must be between 5 and 10, actual: %d", counter)
}

func TestSimpleTaskScheduler_ScheduleWithCron(t *testing.T) {
	scheduler := NewSimpleTaskScheduler(NewDefaultTaskExecutor())

	var counter int32

	task, err := scheduler.ScheduleWithCron(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
		<-time.After(500 * time.Millisecond)
	}, "0-59/2 * * * * *")

	assert.Nil(t, err)

	<-time.After(10 * time.Second)
	task.Cancel()
	assert.True(t, counter >= 5,
		"number of scheduled task execution must be at least 5, actual: %d", counter)
}

func TestSimpleTaskScheduler_Shutdown(t *testing.T) {
	scheduler := NewSimpleTaskScheduler(NewDefaultTaskExecutor())

	var counter int32

	_, err := scheduler.ScheduleAtFixedRate(func(ctx context.Context) {
		atomic.AddInt32(&counter, 1)
		<-time.After(500 * time.Millisecond)
	}, 1*time.Second)

	assert.Nil(t, err)

	<-time.After(2 * time.Second)
	scheduler.Shutdown()

	expected := counter
	<-time.After(3 * time.Second)

	assert.True(t, scheduler.IsShutdown())
	assert.Equal(t, expected, counter,
		"after shutdown, previously scheduled tasks should not be rescheduled", counter)
}


---
context/examples/chrono-src/task.go
---
package chrono

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"sync"
	"time"
)

type Task func(ctx context.Context)

type SchedulerTask struct {
	task      Task
	startTime time.Time
	location  *time.Location
}

func CreateSchedulerTask(task Task, options ...Option) (*SchedulerTask, error) {
	if task == nil {
		return nil, errors.New("task cannot be nil")
	}

	runnableTask := &SchedulerTask{
		task:      task,
		startTime: time.Time{},
		location:  time.Local,
	}

	for _, option := range options {
		err := option(runnableTask)

		if err != nil {
			return nil, err
		}
	}

	return runnableTask, nil
}

func (task *SchedulerTask) GetInitialDelay() time.Duration {
	if task.startTime.IsZero() {
		return 0
	}

	now := time.Now().In(task.location)
	diff := time.Date(task.startTime.Year(), task.startTime.Month(), task.startTime.Day(), task.startTime.Hour(), task.startTime.Minute(), task.startTime.Second(), 0, time.Local).Sub(
		time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second(), 0, time.Local))

	if diff < 0 {
		return 0
	}

	return diff
}

type Option func(task *SchedulerTask) error

func WithTime(t time.Time) Option {
	return func(task *SchedulerTask) error {
		task.startTime = time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), 0, time.Local)

		if t.Location() != nil && t.Location() != time.Local {
			task.location = t.Location()
		}

		return nil
	}
}

// Deprecated: Use WithTime instead.
func WithStartTime(year int, month time.Month, day, hour, min, sec int) Option {
	return func(task *SchedulerTask) error {
		task.startTime = time.Date(year, month, day, hour, min, sec, 0, time.Local)
		return nil
	}
}

func WithLocation(location string) Option {
	return func(task *SchedulerTask) error {
		loadedLocation, err := time.LoadLocation(location)

		if err != nil {
			return fmt.Errorf("location not loaded : %s", location)
		}

		task.location = loadedLocation
		return nil
	}
}

type ScheduledTask interface {
	Cancel()
	IsCancelled() bool
}

type ScheduledRunnableTask struct {
	id          int
	task        Task
	taskMu      sync.RWMutex
	triggerTime time.Time
	period      time.Duration
	fixedRate   bool
	cancelled   bool
}

func CreateScheduledRunnableTask(id int, task Task, triggerTime time.Time, period time.Duration, fixedRate bool) (*ScheduledRunnableTask, error) {
	if task == nil {
		return nil, errors.New("task cannot be nil")
	}

	if period < 0 {
		period = 0
	}

	return &ScheduledRunnableTask{
		id:          id,
		task:        task,
		triggerTime: triggerTime,
		period:      period,
		fixedRate:   fixedRate,
	}, nil
}

func (scheduledRunnableTask *ScheduledRunnableTask) Cancel() {
	scheduledRunnableTask.taskMu.Lock()
	defer scheduledRunnableTask.taskMu.Unlock()
	scheduledRunnableTask.cancelled = true
}

func (scheduledRunnableTask *ScheduledRunnableTask) IsCancelled() bool {
	scheduledRunnableTask.taskMu.Lock()
	defer scheduledRunnableTask.taskMu.Unlock()
	return scheduledRunnableTask.cancelled
}

func (scheduledRunnableTask *ScheduledRunnableTask) getDelay() time.Duration {
	return scheduledRunnableTask.triggerTime.Sub(time.Now())
}

func (scheduledRunnableTask *ScheduledRunnableTask) isPeriodic() bool {
	return scheduledRunnableTask.period != 0
}

func (scheduledRunnableTask *ScheduledRunnableTask) isFixedRate() bool {
	return scheduledRunnableTask.fixedRate
}

type ScheduledTaskQueue []*ScheduledRunnableTask

func (queue ScheduledTaskQueue) Len() int {
	return len(queue)
}

func (queue ScheduledTaskQueue) Swap(i, j int) {
	queue[i], queue[j] = queue[j], queue[i]
}

func (queue ScheduledTaskQueue) Less(i, j int) bool {
	return queue[i].triggerTime.Before(queue[j].triggerTime)
}

func (queue ScheduledTaskQueue) SorByTriggerTime() {
	sort.Sort(queue)
}

type TriggerTask struct {
	task                 Task
	currentScheduledTask *ScheduledRunnableTask
	executor             TaskExecutor
	triggerContext       *SimpleTriggerContext
	triggerContextMu     sync.RWMutex
	trigger              Trigger
	nextTriggerTime      time.Time
}

func CreateTriggerTask(task Task, executor TaskExecutor, trigger Trigger) (*TriggerTask, error) {
	if task == nil {
		return nil, errors.New("task cannot be nil")
	}

	if executor == nil {
		return nil, errors.New("executor cannot be nil")
	}

	if trigger == nil {
		return nil, errors.New("trigger cannot be nil")
	}

	return &TriggerTask{
		task:           task,
		executor:       executor,
		triggerContext: NewSimpleTriggerContext(),
		trigger:        trigger,
	}, nil
}

func (task *TriggerTask) Cancel() {
	task.triggerContextMu.Lock()
	defer task.triggerContextMu.Unlock()
	task.currentScheduledTask.Cancel()
}

func (task *TriggerTask) IsCancelled() bool {
	task.triggerContextMu.Lock()
	defer task.triggerContextMu.Unlock()
	return task.currentScheduledTask.IsCancelled()
}

func (task *TriggerTask) Schedule() (ScheduledTask, error) {
	task.triggerContextMu.Lock()
	defer task.triggerContextMu.Unlock()

	task.nextTriggerTime = task.trigger.NextExecutionTime(task.triggerContext)

	if task.nextTriggerTime.IsZero() {
		return nil, errors.New("could not schedule task because of the fact that schedule time is zero")
	}

	initialDelay := task.nextTriggerTime.Sub(time.Now())

	currentScheduledTask, err := task.executor.Schedule(task.Run, initialDelay)

	if err != nil {
		return nil, err
	}

	task.currentScheduledTask = currentScheduledTask.(*ScheduledRunnableTask)
	return task, nil
}

func (task *TriggerTask) Run(ctx context.Context) {
	task.triggerContextMu.Lock()

	executionTime := time.Now()
	task.task(ctx)
	completionTime := time.Now()

	task.triggerContext.Update(completionTime, executionTime, task.nextTriggerTime)
	task.triggerContextMu.Unlock()

	if !task.IsCancelled() {
		task.Schedule()
	}
}


---
context/examples/chrono-src/task_test.go
---
package chrono

import (
	"context"
	"errors"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"testing"
	"time"
)

func TestNewSchedulerTask(t *testing.T) {
	_, err := CreateSchedulerTask(nil)
	assert.Error(t, err)
}

func TestNewSchedulerTask_WithLocation(t *testing.T) {
	_, err := CreateSchedulerTask(func(ctx context.Context) {

	}, WithLocation("Europe/Istanbul"))
	assert.Nil(t, err)
}

func TestNewSchedulerTask_WithInvalidLocation(t *testing.T) {
	_, err := CreateSchedulerTask(func(ctx context.Context) {

	}, WithLocation("Europe"))
	assert.Error(t, err)
}

func TestNewScheduledRunnableTask(t *testing.T) {
	task, _ := CreateScheduledRunnableTask(0, func(ctx context.Context) {

	}, time.Now(), -1, true)

	assert.Equal(t, task.period, 0*time.Second)

	_, err := CreateScheduledRunnableTask(0, nil, time.Now(), -1, true)
	assert.Error(t, err)
}

func TestNewTriggerTask(t *testing.T) {
	trigger, err := CreateCronTrigger("* * * * * *", time.Local)
	assert.Nil(t, err)

	_, err = CreateTriggerTask(nil, NewDefaultTaskExecutor(), trigger)
	assert.Error(t, err)

	_, err = CreateTriggerTask(func(ctx context.Context) {

	}, nil, trigger)
	assert.Error(t, err)

	_, err = CreateTriggerTask(func(ctx context.Context) {

	}, NewDefaultTaskExecutor(), nil)
}

type zeroTrigger struct {
}

func (trigger *zeroTrigger) NextExecutionTime(ctx TriggerContext) time.Time {
	return time.Time{}
}

func TestTriggerTask_Schedule(t *testing.T) {
	task, _ := CreateTriggerTask(func(ctx context.Context) {}, NewDefaultTaskExecutor(), &zeroTrigger{})
	_, err := task.Schedule()
	assert.NotNil(t, err)
}

type scheduledExecutorMock struct {
	mock.Mock
}

func (executor scheduledExecutorMock) Schedule(task Task, delay time.Duration) (ScheduledTask, error) {
	result := executor.Called(task, delay)
	return result.Get(0).(ScheduledTask), result.Error(1)
}

func (executor scheduledExecutorMock) ScheduleWithFixedDelay(task Task, initialDelay time.Duration, delay time.Duration) (ScheduledTask, error) {
	result := executor.Called(task, initialDelay, delay)
	return result.Get(0).(ScheduledTask), result.Error(1)
}

func (executor scheduledExecutorMock) ScheduleAtFixedRate(task Task, initialDelay time.Duration, period time.Duration) (ScheduledTask, error) {
	result := executor.Called(task, initialDelay, period)
	return result.Get(0).(ScheduledTask), result.Error(1)
}

func (executor scheduledExecutorMock) IsShutdown() bool {
	result := executor.Called()
	return result.Bool(0)
}

func (executor scheduledExecutorMock) Shutdown() chan bool {
	result := executor.Called()
	return result.Get(0).(chan bool)
}

func TestTriggerTask_ScheduleWithError(t *testing.T) {
	scheduledExecutorMock := &scheduledExecutorMock{}

	scheduledExecutorMock.On("Schedule", mock.AnythingOfType("Task"), mock.AnythingOfType("time.Duration")).
		Return((*ScheduledRunnableTask)(nil), errors.New("test error"))

	trigger, err := CreateCronTrigger("* * * * * *", time.Local)
	assert.Nil(t, err)

	task, _ := CreateTriggerTask(func(ctx context.Context) {}, scheduledExecutorMock, trigger)
	_, err = task.Schedule()

	assert.NotNil(t, err)
}


---
context/examples/chrono-src/trigger.go
---
package chrono

import "time"

type TriggerContext interface {
	LastCompletionTime() time.Time
	LastExecutionTime() time.Time
	LastTriggeredExecutionTime() time.Time
}

type SimpleTriggerContext struct {
	lastCompletionTime         time.Time
	lastExecutionTime          time.Time
	lastTriggeredExecutionTime time.Time
}

func NewSimpleTriggerContext() *SimpleTriggerContext {
	return &SimpleTriggerContext{}
}

func (ctx *SimpleTriggerContext) Update(lastCompletionTime time.Time, lastExecutionTime time.Time, lastTriggeredExecutionTime time.Time) {
	ctx.lastCompletionTime = lastCompletionTime
	ctx.lastExecutionTime = lastExecutionTime
	ctx.lastTriggeredExecutionTime = lastTriggeredExecutionTime
}

func (ctx *SimpleTriggerContext) LastCompletionTime() time.Time {
	return ctx.lastCompletionTime
}

func (ctx *SimpleTriggerContext) LastExecutionTime() time.Time {
	return ctx.lastExecutionTime
}

func (ctx *SimpleTriggerContext) LastTriggeredExecutionTime() time.Time {
	return ctx.lastTriggeredExecutionTime
}

type Trigger interface {
	NextExecutionTime(ctx TriggerContext) time.Time
}

type CronTrigger struct {
	cronExpression *CronExpression
	location       *time.Location
}

func CreateCronTrigger(expression string, location *time.Location) (*CronTrigger, error) {
	cron, err := ParseCronExpression(expression)

	if err != nil {
		return nil, err
	}

	trigger := &CronTrigger{
		cron,
		time.Local,
	}

	if location != nil {
		trigger.location = location
	}

	return trigger, nil
}

func (trigger *CronTrigger) NextExecutionTime(ctx TriggerContext) time.Time {
	now := time.Now()
	lastCompletion := ctx.LastCompletionTime()

	if !lastCompletion.IsZero() {

		lastExecution := ctx.LastTriggeredExecutionTime()

		if !lastExecution.IsZero() && now.Before(lastExecution) {
			now = lastExecution
		}

	}

	originalLocation := now.Location()

	convertedTime := now.In(trigger.location)
	convertedTime = time.Date(convertedTime.Year(),
		convertedTime.Month(),
		convertedTime.Day(),
		convertedTime.Hour(),
		convertedTime.Minute(),
		convertedTime.Second(),
		convertedTime.Nanosecond(),
		trigger.location)

	next := trigger.cronExpression.NextTime(convertedTime)

	// there is a bug causes timezone changing when an operation is performed on time value like add, subtraction
	// to resolve this issue, we use a workaround solution
	next = time.Date(next.Year(),
		next.Month(),
		next.Day(),
		next.Hour(),
		next.Minute(),
		next.Second(),
		next.Nanosecond(),
		trigger.location)

	return next.In(originalLocation)
}


---
context/examples/chrono-src/trigger_test.go
---
package chrono

import (
	"github.com/stretchr/testify/assert"
	"testing"
	"time"
)

func TestSimpleTriggerContext(t *testing.T) {
	ctx := NewSimpleTriggerContext()
	now := time.Now()
	ctx.lastExecutionTime = now
	ctx.lastTriggeredExecutionTime = now
	ctx.lastCompletionTime = now

	assert.Equal(t, now, ctx.LastExecutionTime())
	assert.Equal(t, now, ctx.LastCompletionTime())
	assert.Equal(t, now, ctx.LastTriggeredExecutionTime())
}

func TestNewCronTrigger(t *testing.T) {
	trigger, err := CreateCronTrigger("", time.Local)
	assert.Error(t, err)
	assert.Nil(t, trigger)
}


---
context/examples/sched-module/go.mod
---
module github.com/risor-io/risor/modules/sched

go 1.23.0

replace github.com/risor-io/risor => ../..

require (
	codnect.io/chrono v1.1.3
	github.com/risor-io/risor v1.7.0
	github.com/stretchr/testify v1.10.0
)

require (
	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
	github.com/kr/text v0.2.0 // indirect
	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)


---
context/examples/sched-module/go.sum
---
codnect.io/chrono v1.1.3 h1:24PYU38bQ14hGUBOclYOkTrrSGPaQLEXFoC9etgm6mU=
codnect.io/chrono v1.1.3/go.mod h1:zmwApcg24IP3E9fgdiupopV1L/QOOtXsqtvivDDaKfk=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 h1:Jamvg5psRIccs7FGNTlIRMkT8wgtp5eCXdBlqhYGL6U=
github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rogpeppe/go-internal v1.13.1 h1:KvO1DLK/DRN07sQ1LQKScxyZJuNnedQ5/wKSR38lUII=
github.com/rogpeppe/go-internal v1.13.1/go.mod h1:uMEvuHeurkdAXX61udpOXGD/AzZDWNMNyH2VO9fmH0o=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=


---
context/examples/sched-module/sched.go
---
package sched

import (
	"context"
	"sync"
	"time"

	"codnect.io/chrono"
	"github.com/risor-io/risor/object"
)

var (
	// Global scheduler instance
	scheduler     chrono.TaskScheduler
	schedulerOnce sync.Once
	schedulerMu   sync.Mutex
)

// getScheduler returns the singleton task scheduler instance.
// It lazily initializes the scheduler on first use.
func getScheduler() chrono.TaskScheduler {
	schedulerOnce.Do(func() {
		scheduler = chrono.NewDefaultTaskScheduler()
	})
	return scheduler
}

// Module returns the sched module.
func Module() *object.Module {
	return object.NewBuiltinsModule(
		"sched", map[string]object.Object{
			"cron":  object.NewBuiltin("sched.cron", Cron),
			"every": object.NewBuiltin("sched.every", Every),
			"once":  object.NewBuiltin("sched.once", Once),
		},
	)
}

// Cron schedules a function to run at a specific time using a cron like expression.
//
// The first argument is the cron expression.
// The second argument is the function to be scheduled.
func Cron(ctx context.Context, args ...object.Object) object.Object {
	if len(args) != 2 {
		return object.Errorf("missing arguments, 2 required")
	}

	cronLine, err := object.AsString(args[0])
	if err != nil {
		return err
	}

	fn, ok := args[1].(*object.Function)
	if !ok {
		return object.Errorf("expected function, got %s", args[1].Type())
	}

	// GetCloneCallFunc returns a function safe to be called from a different goroutine.
	cfunc, ok := object.GetCloneCallFunc(ctx)
	if !ok {
		return object.EvalErrorf("eval error: context did not contain a call function")
	}

	schedulerMu.Lock()
	defer schedulerMu.Unlock()

	taskScheduler := getScheduler()
	t, nerr := taskScheduler.ScheduleWithCron(func(context.Context) {
		_, _ = cfunc(ctx, fn, nil)
	}, cronLine)
	if nerr != nil {
		return object.NewError(nerr)
	}

	return &task{t: t}
}

// Every schedules a function to run every n seconds.
//
// The first argument is the interval in seconds (float).
// The second argument is the function to be scheduled.
func Every(ctx context.Context, args ...object.Object) object.Object {
	if len(args) != 2 {
		return object.Errorf("missing arguments, 2 required")
	}

	dur, err := object.AsString(args[0])
	if err != nil {
		return err
	}

	fn, ok := args[1].(*object.Function)
	if !ok {
		return object.Errorf("expected function, got %s", args[1].Type())
	}

	// GetCloneCallFunc returns a function safe to be called from a different goroutine.
	cfunc, ok := object.GetCloneCallFunc(ctx)
	if !ok {
		return object.EvalErrorf("eval error: context did not contain a call function")
	}

	duration, nerr := time.ParseDuration(dur)
	if nerr != nil {
		return object.NewError(nerr)
	}

	schedulerMu.Lock()
	defer schedulerMu.Unlock()

	taskScheduler := getScheduler()
	t, nerr := taskScheduler.ScheduleAtFixedRate(func(context.Context) {
		_, _ = cfunc(ctx, fn, nil)
	}, duration)
	if nerr != nil {
		return object.NewError(err)
	}

	return &task{t: t}
}

// Once schedules a function to run once.
//
// The first argument is the interval in seconds (float).
// The second argument is the function to be scheduled.
func Once(ctx context.Context, args ...object.Object) object.Object {
	if len(args) != 2 {
		return object.Errorf("missing arguments, 2 required")
	}

	dur, err := object.AsString(args[0])
	if err != nil {
		return err
	}

	duration, nerr := time.ParseDuration(dur)
	if nerr != nil {
		return object.NewError(nerr)
	}

	start := time.Now().Add(duration)

	fn, ok := args[1].(*object.Function)
	if !ok {
		return object.Errorf("expected function, got %s", args[1].Type())
	}

	// GetCloneCallFunc returns a function safe to be called from a different goroutine.
	cfunc, ok := object.GetCloneCallFunc(ctx)
	if !ok {
		return object.EvalErrorf("eval error: context did not contain a call function")
	}

	schedulerMu.Lock()
	defer schedulerMu.Unlock()

	taskScheduler := getScheduler()
	t, nerr := taskScheduler.Schedule(func(ctx context.Context) {
		_, _ = cfunc(ctx, fn, nil)
	}, chrono.WithTime(start))
	if nerr != nil {
		return object.NewError(err)
	}

	return &task{t: t}
}


---
context/examples/sched-module/sched.md
---
# sched

The `sched` module exposes a simple interface to schedule tasks, powered by [chrono](https://github.com/codnect/chrono).

```go
once := sched.once("1s", func(){
    print("once")
})

cron := sched.cron("*/1 * * * * *", func(){
    print("hola")
})

print(cron.is_running())

every := sched.every("1m", func() {
    print("every 1 minute")
})

for {
    time.sleep(1)
}
```

## Functions

Functions are non-blocking and return a `task` object.

### cron

```go filename="Function signature"
cron(cronline string, fn func)
```

Creates a new cron job.

The `cronline` string is a space-separated list of 6 fields, representing the time to run the task.

```
SECOND MINUTE HOUR DAY MONTH DAYOFWEEK
   *      *     *   *    *      *
```

Some examples:

- `* * * * * *` every second
- `*/5 * * * * *` every 5 seconds
- `0 * * * * *` every minute
- `0 0 * * * *` every hour
- `20 45 18 5-20/3 * *` every day at 18:45:20, from the 5th to the 20th of the month, every 3 days
- `0 0 0 1 SEP *` every year on September 1st at midnight
- `0 0 0 1 5 SUN` every year on the first Sunday of May at midnight


```go copy filename="Example"
// Run every second
task := sched.cron("*/1 * * * * *", func() {
	print("hello world!")
})
```

Functions run in a separate goroutine, and errors are ignored, so the main program can continue to run. Make sure to handle errors in your function.

### every

```go filename="Function signature"
every(duration string, fn func)
```

Creates a new task that runs regularly, at the specified duration.

The string format is documented in [the standard Go library](https://pkg.go.dev/time#ParseDuration).

```go copy filename="Example"
// Run every minute
task := sched.every("1m"", func() {
	print("hello world!")
})
```

### once

```go filename="Function signature"
once(duration string, fn func)
```

Creates a new task that runs once, after the specified duration.

```go copy filename="Example"
// Run a task in one 1h, once
task := sched.once("1h", func() {
	print("hello world!")
})
```

`cron` can be used to run a task once at a specific time, if more control is needed.

## Types

### task

A Task object returned by `cron`, `every` and `once` functions.

#### Attributes

| Name       | Type   | Description                 |
| ---------- | ------ | --------------------------- |
| cancel     | func() | Cancels the task            |
| is_running | func() | True if the task is running |


---
context/examples/sched-module/sched_test.go
---
package sched

import (
	"context"
	"testing"
	"time"

	"github.com/risor-io/risor/object"
	"github.com/stretchr/testify/assert"
)

func TestCron(t *testing.T) {
	var executed int
	callFn := func(ctx context.Context, fn *object.Function, args []object.Object) (object.Object, error) {
		executed++
		return nil, nil
	}
	ctx := object.WithCloneCallFunc(context.Background(), callFn)
	var fn *object.Function

	cronExpr := object.NewString("invalid-cronline")
	task := Cron(ctx, cronExpr, fn)
	assert.True(t, object.IsError(task))

	cronExpr = object.NewString("*/1 * * * * *") // Every second
	task = Cron(ctx, cronExpr, fn)
	assert.False(t, object.IsError(task))
	assert.NotNil(t, task)
	assert.Equal(t, "sched.task", string(task.Type()))
	assert.Equal(t, 0, executed)

	_, ok := task.GetAttr("is_running")
	assert.True(t, ok)

	// Wait a second to allow the cron job to execute
	time.Sleep(1 * time.Second)
	assert.Equal(t, 1, executed)

	_, ok = task.GetAttr("cancel")
	assert.True(t, ok)
}

func TestEvery(t *testing.T) {
	var executed int
	callFn := func(ctx context.Context, fn *object.Function, args []object.Object) (object.Object, error) {
		if executed == 2 {
			return nil, nil
		}
		executed++
		return nil, nil
	}
	ctx := object.WithCloneCallFunc(context.Background(), callFn)
	var fn *object.Function

	// Schedule the function to run every 1 millisecond
	interval := object.NewString("1ms")
	task := Every(ctx, interval, fn)
	assert.False(t, object.IsError(task))
	assert.Equal(t, "sched.task", string(task.Type()))

	// Wait for a few milliseconds to allow the job to execute
	time.Sleep(50 * time.Millisecond)
	assert.Equal(t, 2, executed)

	interval = object.NewString("1foo")
	task = Every(ctx, interval, fn)
	assert.True(t, object.IsError(task))
}

func TestOnce(t *testing.T) {
	var executed int
	callFn := func(ctx context.Context, fn *object.Function, args []object.Object) (object.Object, error) {
		executed++
		return nil, nil
	}
	ctx := object.WithCloneCallFunc(context.Background(), callFn)
	var fn *object.Function

	// Schedule the function to run every 1ms
	interval := object.NewString("1ms")
	task := Once(ctx, interval, fn)
	assert.False(t, object.IsError(task))
	assert.Equal(t, "sched.task", string(task.Type()))

	// Wait some time for the job to complete
	time.Sleep(50 * time.Millisecond)
	assert.Equal(t, 1, executed)
}

func TestEqual(t *testing.T) {
	callFn := func(ctx context.Context, fn *object.Function, args []object.Object) (object.Object, error) {
		return nil, nil
	}
	ctx := object.WithCloneCallFunc(context.Background(), callFn)
	var fn *object.Function

	cronExpr := object.NewString("* * * * * *")
	task := Cron(ctx, cronExpr, fn)
	task2 := Cron(ctx, cronExpr, fn)

	assert.True(t, task.Equals(task).(*object.Bool).Value())
	assert.False(t, task.Equals(task2).(*object.Bool).Value())
}


---
context/examples/sched-module/type.go
---
package sched

import (
	"context"

	"codnect.io/chrono"
	"github.com/risor-io/risor/errz"
	"github.com/risor-io/risor/object"
	"github.com/risor-io/risor/op"
)

type task struct {
	Name string
	t    chrono.ScheduledTask
}

// IsTruthy returns true if the task is not cancelled.
func (t *task) IsTruthy() bool {
	return !t.t.IsCancelled()
}

// Cost returns the cost of the task.
func (t *task) Cost() int {
	return 0
}

// Equals returns true if the task is equal to the other object.
func (t *task) Equals(other object.Object) object.Object {
	so, ok := other.(*task)
	if !ok {
		return object.False
	}
	ok = (*t == *so)
	return object.NewBool(ok)
}

// Inspect returns the string representation of the task.
func (t *task) Inspect() string {
	return "sched.task"
}

// Type returns the type of the task.
func (t *task) Type() object.Type {
	return object.Type("sched.task")
}

func (t *task) Interface() any {
	return t.t
}

// RunOperation returns a type error for unsupported operations.
func (t *task) RunOperation(opType op.BinaryOpType, right object.Object) object.Object {
	return object.TypeErrorf("type error: unsupported operation for job: %v", opType)
}

// GetAttr returns the attribute of the task.
func (t *task) GetAttr(name string) (object.Object, bool) {
	switch name {
	case "cancel":
		return object.NewBuiltin("sched.task.stop", func(ctx context.Context, args ...object.Object) object.Object {
			t.t.Cancel()
			return nil
		}), true
	case "is_running":
		return object.NewBuiltin("sched.task.is_running", func(ctx context.Context, args ...object.Object) object.Object {
			return object.NewBool(!t.t.IsCancelled())
		}), true
	}
	return nil, false
}

func (t *task) SetAttr(name string, value object.Object) error {
	return errz.TypeErrorf("type error: object has no attribute %q", name)
}


---
context/examples/cli-module/app.go
---
package cli

import (
	"context"
	"fmt"

	"github.com/risor-io/risor/arg"
	"github.com/risor-io/risor/errz"
	"github.com/risor-io/risor/object"
	"github.com/risor-io/risor/op"
	"github.com/risor-io/risor/os"
	ucli "github.com/urfave/cli/v2"
)

const APP object.Type = "cli.app"

type App struct {
	value *ucli.App
}

func (app *App) Type() object.Type {
	return APP
}

func (app *App) Inspect() string {
	return fmt.Sprintf("%s()", app.Type())
}

func (app *App) Interface() interface{} {
	return app.value
}

func (app *App) IsTruthy() bool {
	return true
}

func (app *App) Cost() int {
	return 0
}

func (app *App) MarshalJSON() ([]byte, error) {
	return nil, errz.TypeErrorf("type error: unable to marshal %s", APP)
}

func (app *App) RunOperation(opType op.BinaryOpType, right object.Object) object.Object {
	return object.TypeErrorf("type error: unsupported operation for %s: %v", APP, opType)
}

func (app *App) Equals(other object.Object) object.Object {
	return object.NewBool(app == other)
}

func (app *App) GetAttr(name string) (object.Object, bool) {
	switch name {
	case "name":
		return object.NewString(app.value.Name), true
	case "help_name":
		return object.NewString(app.value.HelpName), true
	case "usage":
		return object.NewString(app.value.Usage), true
	case "usage_text":
		return object.NewString(app.value.UsageText), true
	case "args":
		return object.NewBool(app.value.Args), true
	case "args_usage":
		return object.NewString(app.value.ArgsUsage), true
	case "version":
		return object.NewString(app.value.Version), true
	case "description":
		return object.NewString(app.value.Description), true
	case "default_command":
		return object.NewString(app.value.DefaultCommand), true
	case "commands":
		var commands []object.Object
		for _, cmd := range app.value.Commands {
			commands = append(commands, NewCommand(cmd))
		}
		return object.NewList(commands), true
	case "flags":
		var flags []object.Object
		for _, flag := range app.value.Flags {
			flags = append(flags, NewFlag(flag))
		}
		return object.NewList(flags), true
	case "enable_bash_completion":
		return object.NewBool(app.value.EnableBashCompletion), true
	case "hide_help":
		return object.NewBool(app.value.HideHelp), true
	case "hide_help_command":
		return object.NewBool(app.value.HideHelpCommand), true
	case "hide_version":
		return object.NewBool(app.value.HideVersion), true
	case "run":
		return object.NewBuiltin("cli.app.run",
			func(ctx context.Context, args ...object.Object) object.Object {
				if err := arg.RequireRange("cli.app.run", 0, 1, args); err != nil {
					return err
				}
				var strArgs []string
				if len(args) == 0 {
					strArgs = os.GetDefaultOS(ctx).Args()
				} else {
					var errObj *object.Error
					strArgs, errObj = object.AsStringSlice(args[0])
					if errObj != nil {
						return errObj
					}
				}
				if err := app.value.RunContext(ctx, strArgs); err != nil {
					return object.NewError(err)
				}
				return object.Nil
			}), true
	}
	return nil, false
}

func (app *App) SetAttr(name string, value object.Object) error {
	switch name {
	case "name":
		str, ok := value.(*object.String)
		if !ok {
			return object.TypeErrorf("type error: expected string, got %s", value.Type())
		}
		app.value.Name = str.Value()
	case "help_name":
		str, ok := value.(*object.String)
		if !ok {
			return object.TypeErrorf("type error: expected string, got %s", value.Type())
		}
		app.value.HelpName = str.Value()
	case "usage":
		str, ok := value.(*object.String)
		if !ok {
			return object.TypeErrorf("type error: expected string, got %s", value.Type())
		}
		app.value.Usage = str.Value()
	case "usage_text":
		str, ok := value.(*object.String)
		if !ok {
			return object.TypeErrorf("type error: expected string, got %s", value.Type())
		}
		app.value.UsageText = str.Value()
	case "args":
		b, ok := value.(*object.Bool)
		if !ok {
			return object.TypeErrorf("type error: expected bool, got %s", value.Type())
		}
		app.value.Args = b.Value()
	case "args_usage":
		str, ok := value.(*object.String)
		if !ok {
			return object.TypeErrorf("type error: expected string, got %s", value.Type())
		}
		app.value.ArgsUsage = str.Value()
	case "version":
		str, ok := value.(*object.String)
		if !ok {
			return object.TypeErrorf("type error: expected string, got %s", value.Type())
		}
		app.value.Version = str.Value()
	case "description":
		str, ok := value.(*object.String)
		if !ok {
			return object.TypeErrorf("type error: expected string, got %s", value.Type())
		}
		app.value.Description = str.Value()
	case "default_command":
		str, ok := value.(*object.String)
		if !ok {
			return object.TypeErrorf("type error: expected string, got %s", value.Type())
		}
		app.value.DefaultCommand = str.Value()
	case "enable_bash_completion":
		b, ok := value.(*object.Bool)
		if !ok {
			return object.TypeErrorf("type error: expected bool, got %s", value.Type())
		}
		app.value.EnableBashCompletion = b.Value()
	case "hide_help":
		b, ok := value.(*object.Bool)
		if !ok {
			return object.TypeErrorf("type error: expected bool, got %s", value.Type())
		}
		app.value.HideHelp = b.Value()
	case "hide_help_command":
		b, ok := value.(*object.Bool)
		if !ok {
			return object.TypeErrorf("type error: expected bool, got %s", value.Type())
		}
		app.value.HideHelpCommand = b.Value()
	case "hide_version":
		b, ok := value.(*object.Bool)
		if !ok {
			return object.TypeErrorf("type error: expected bool, got %s", value.Type())
		}
		app.value.HideVersion = b.Value()
	default:
		return object.TypeErrorf("type error: %s object has no attribute %q", APP, name)
	}
	return nil
}

func NewApp(ctx context.Context, opts *object.Map) (*App, error) {
	app := &ucli.App{}

	// Handle string fields
	for _, field := range []string{
		"name", "help_name", "usage", "usage_text", "args_usage",
		"version", "description", "default_command",
	} {
		if opt := opts.Get(field); opt != object.Nil {
			str, ok := opt.(*object.String)
			if !ok {
				return nil, object.TypeErrorf("type error: %s must be a string", field)
			}
			switch field {
			case "name":
				app.Name = str.Value()
			case "help_name":
				app.HelpName = str.Value()
			case "usage":
				app.Usage = str.Value()
			case "usage_text":
				app.UsageText = str.Value()
			case "args_usage":
				app.ArgsUsage = str.Value()
			case "version":
				app.Version = str.Value()
			case "description":
				app.Description = str.Value()
			case "default_command":
				app.DefaultCommand = str.Value()
			}
		}
	}

	// Handle boolean fields
	for _, field := range []string{
		"args", "enable_bash_completion", "hide_help",
		"hide_help_command", "hide_version",
	} {
		if opt := opts.Get(field); opt != object.Nil {
			b, ok := opt.(*object.Bool)
			if !ok {
				return nil, object.TypeErrorf("type error: %s must be a bool", field)
			}
			switch field {
			case "args":
				app.Args = b.Value()
			case "enable_bash_completion":
				app.EnableBashCompletion = b.Value()
			case "hide_help":
				app.HideHelp = b.Value()
			case "hide_help_command":
				app.HideHelpCommand = b.Value()
			case "hide_version":
				app.HideVersion = b.Value()
			}
		}
	}

	// Handle commands
	if commandsOpt := opts.Get("commands"); commandsOpt != object.Nil {
		commands, ok := commandsOpt.(*object.List)
		if !ok {
			return nil, object.TypeErrorf("type error: commands must be a list")
		}
		for _, cmdOpt := range commands.Value() {
			cmd, ok := cmdOpt.(*Command)
			if !ok {
				return nil, object.TypeErrorf("type error: expected a command (got %s)", cmdOpt.Type())
			}
			app.Commands = append(app.Commands, cmd.value)
		}
	}

	// Handle flags
	if flagsOpt := opts.Get("flags"); flagsOpt != object.Nil {
		flags, ok := flagsOpt.(*object.List)
		if !ok {
			return nil, object.TypeErrorf("type error: flags must be a list")
		}
		for _, flagOpt := range flags.Value() {
			flag, ok := flagOpt.(*Flag)
			if !ok {
				return nil, object.TypeErrorf("type error: expected a flag (got %s)", flagOpt.Type())
			}
			app.Flags = append(app.Flags, flag.value)
		}
	}

	stdin := os.GetDefaultOS(ctx).Stdin()
	stdout := os.GetDefaultOS(ctx).Stdout()
	app.Reader = stdin
	app.Writer = stdout
	app.ErrWriter = stdout

	if actionOpt := opts.Get("action"); actionOpt != object.Nil {
		if action, ok := actionOpt.(*object.Function); ok {
			app.Action = func(c *ucli.Context) error {
				callFunc, ok := object.GetCallFunc(c.Context)
				if !ok {
					return fmt.Errorf("no call function found")
				}
				args := []object.Object{NewCtx(c)}
				if _, err := callFunc(c.Context, action, args); err != nil {
					return err
				}
				return nil
			}
		} else {
			return nil, errz.TypeErrorf("type error: action must be a function")
		}
	}

	return &App{value: app}, nil
}


---
context/examples/cli-module/cli.go
---
package cli

import (
	"context"

	"github.com/risor-io/risor/arg"
	"github.com/risor-io/risor/object"
	ucli "github.com/urfave/cli/v2"
)

func AppFunc(ctx context.Context, args ...object.Object) object.Object {
	if err := arg.Require("cli.app", 1, args); err != nil {
		return err
	}
	opts, objErr := object.AsMap(args[0])
	if objErr != nil {
		return objErr
	}
	app, err := NewApp(ctx, opts)
	if err != nil {
		return object.NewError(err)
	}
	return app
}

func FlagFunc(ctx context.Context, args ...object.Object) object.Object {
	if err := arg.Require("cli.flag", 1, args); err != nil {
		return err
	}
	optsMap, objErr := object.AsMap(args[0])
	if objErr != nil {
		return objErr
	}
	opts := optsMap.Value()

	// Infer flag type from the options
	// - If `type` is set, use that
	// - If `value` is set, match its type (string, int, bool, string slice)
	var flag *Flag
	flagValue, hasFlagValue := opts["value"]
	if typ, ok := opts["type"]; ok {
		delete(opts, "type")
		typStr, ok := typ.(*object.String)
		if !ok {
			return object.Errorf("cli.flag type expected string (got %s)", typ.Type())
		}
		switch typStr.Value() {
		case "string":
			flag = NewFlag(&ucli.StringFlag{})
		case "int":
			flag = NewFlag(&ucli.Int64Flag{})
		case "float":
			flag = NewFlag(&ucli.Float64Flag{})
		case "bool":
			flag = NewFlag(&ucli.BoolFlag{})
		case "string_slice":
			flag = NewFlag(&ucli.StringSliceFlag{})
		case "int_slice":
			flag = NewFlag(&ucli.Int64SliceFlag{})
		case "float_slice":
			flag = NewFlag(&ucli.Float64SliceFlag{})
		default:
			return object.Errorf("unsupported cli.flag type: %s", typStr.Value())
		}
	} else if hasFlagValue {
		switch flagValue.(type) {
		case *object.String:
			flag = NewFlag(&ucli.StringFlag{})
		case *object.Int:
			flag = NewFlag(&ucli.Int64Flag{})
		case *object.Float:
			flag = NewFlag(&ucli.Float64Flag{})
		case *object.Bool:
			flag = NewFlag(&ucli.BoolFlag{})
		}
	}
	if flag == nil {
		return object.Errorf("cli.flag type must be specified")
	}
	if err := setFlagAttrs(flag, opts); err != nil {
		return object.NewError(err)
	}
	return flag
}

func CommandFunc(ctx context.Context, args ...object.Object) object.Object {
	if err := arg.Require("cli.command", 1, args); err != nil {
		return err
	}
	opts, objErr := object.AsMap(args[0])
	if objErr != nil {
		return objErr
	}
	cmd := NewCommand(&ucli.Command{})
	for k, v := range opts.Value() {
		if err := cmd.SetAttr(k, v); err != nil {
			return object.NewError(err)
		}
	}
	return cmd
}

func Module() *object.Module {
	return object.NewBuiltinsModule("cli", map[string]object.Object{
		"app":     object.NewBuiltin("cli.app", AppFunc),
		"command": object.NewBuiltin("cli.command", CommandFunc),
		"flag":    object.NewBuiltin("cli.flag", FlagFunc),
	})
}

func setFlagAttrs(flag *Flag, attrs map[string]object.Object) error {
	for k, v := range attrs {
		if err := flag.SetAttr(k, v); err != nil {
			return err
		}
	}
	return nil
}


---
context/examples/cli-module/cli.md
---
import { Callout } from 'nextra/components';

# cli

Module `cli` is used to build command line apps written in the Risor. Common
CLI features are supported, including commands, flags, arguments, usage, and
automatic help generation.

<Callout type="info" emoji="ℹ️">
  This module is included by default in the Risor CLI, but must be
  independently installed when using Risor as
  a library using `go get github.com/risor-io/risor/modules/cli`
</Callout>

Behind the scenes, this module uses the [urfave/cli](https://cli.urfave.org/) library.

## Getting Started

Create a file named `myapp.risor` with the following contents. Note that you
must include the shebang line including `--` at the top of the file to ensure
that arguments and options are _passed to the app_, rather than being used as
options by the Risor binary itself.

```risor copy filename="myapp.risor"
#!/usr/bin/env risor --

from cli import app, command as c

app({
    name: "myapp",
    description: "My app description",
    commands: [
        c({
            name: "hello",
            description: "Say hello",
            action: func(ctx) {
                print("Hello, world!")
            },
        }),
    ],
}).run()
```

Now make the file executable:

```
$ chmod +x ./myapp.risor
```

You can now run the app as follows:

```
$ ./myapp.risor hello
Hello, world!
```

## Functions

### app

```go filename="Function signature"
app(options map) app
```

Returns a new app initialized with the given options. A simple app may consist
of just a `name`, `description`, and `action` function. Call `.run()` on the
app to run it.

```risor copy filename="Example"
app := cli.app({
    name: "myapp",
    description: "My app description",
    action: func(ctx) {
        print("Hello, world!")
    },
})

app.run()
```

The `app` function supports the following options:

- `action func(ctx)`: The action to run when the app is run.
- `args bool`: Whether this app supports arguments.
- `args_usage string`: Description of the program argument format.
- `commands []cli.command`: A list of commands that the app supports.
- `default_command string`: Name of a command to run if no command names are passed as CLI arguments.
- `description string`: A short description of the app.
- `enable_bash_completion bool`: Enable bash completion commands.
- `flags []cli.flag`: A list of flags that the app supports.
- `help_name string`: Override for the name of the app in help output.
- `hide_help bool`: Hide built-in help command and help flag.
- `hide_help_command bool`: Hide built-in help command but keep help flag (ignored if hide_help is true).
- `hide_version bool`: Hide built-in version flag and VERSION section of help.
- `name string`: The name of the app.
- `usage_text string`: Text to override the USAGE section of help.
- `usage string`: The usage string for the app.
- `version string`: The version of the app.

### command

```go filename="Function signature"
command(options map) command
```

Returns a new command initialized with the given options. Commands are provided
to an app via the app's `commands` option.

```go copy filename="Example"
command := cli.command({
    name: "add",
    description: "Add numbers provided as arguments",
    action: func(ctx) {
        sum := 0
        for _, arg := range ctx.args() {
            sum += int(arg)
        }
        print(sum)
    },
})
```

The `command` function supports the following options:

- `action func(ctx)`: The function to call when the command is invoked.
- `aliases []string`: A list of aliases for the command.
- `args_usage string`: A short description of the arguments of this command.
- `args bool`: Whether this command supports arguments.
- `category string`: The category the command is part of.
- `custom_help_template string`: Text template for the command help topic.
- `description string`: A longer explanation of how the command works.
- `flags []cli.flag`: A list of flags that the command supports.
- `help_name string`: Full name of command for help, defaults to full command name, including parent commands.
- `hidden bool`: Hide this command from help or completion.
- `hide_help_command bool`: Whether to hide the command from the help command.
- `hide_help bool` Hide the built-in help command and help flag.
- `name string`: The name of the command.
- `usage_text string`: Custom text to show in USAGE section of help.
- `usage string`: A short description of the usage of this command.
- `use_short_option_handling bool`: Enables short-option handling so the user can combine several single-character bool flags into one.

### flag

```go filename="Function signature"
flag(options map) flag
```

Returns a flag that may be used with an app or command. Supported flag types
include `string`, `int`, `bool`, `float`, `string_slice`, `int_slice`,
and `float_slice`.

A default value for the flag may be provided using the `value` option. The flag
type is inferred from the `value` option if a `type` is not specified.

```go copy filename="Example string flag"
cli.flag({
    name: "food",
    aliases: ["f"],
    usage: "The type of food to eat",
    env_vars: ["FOOD"], // read from this environment variable, if present
    value: "pizza",     // default value
    type: "string",     // flag type: string, int, bool, etc.
})
```

```go copy filename="Example int flag"
cli.flag({
    name: "count",
    aliases: ["c"],
    usage: "The number of items to process",
    value: 1,
})
```

```go copy filename="Example bool flag"
cli.flag({
    name: "verbose",
    aliases: ["v"],
    usage: "Enable verbose output",
    value: false,
})
```

## Types

### app

An app represents the main entry point for a command-line program. It contains
commands, is customized with flags, and is executed via `app.run()`.

### ctx

A ctx object is passed through to each handler action in a cli app. It is
used to retrieve context-specific args and parsed command-line options.

Attributes on the ctx object include:

| Name             | Type                         | Description                                                             |
| ---------------- | ---------------------------- | ----------------------------------------------------------------------- |
| args             | func() []string              | Returns the command-line arguments                                      |
| narg             | func() int                   | Returns the number of arguments                                         |
| value            | func(name string) object     | Returns the value of the flag corresponding to `name`                   |
| count            | func(name string) int        | Returns the count of the flag corresponding to `name`                   |
| flag_names       | func() []string              | Returns the names of all flags used by this context and parent contexts |
| local_flag_names | func() []string              | Returns the names of all flags used by this context                     |
| is_set           | func(name string) bool       | Returns true if the flag corresponding to `name` is set                 |
| set              | func(name string, value obj) | Sets the value of the flag corresponding to `name`                      |
| num_flags        | func() int                   | Returns the number of flags set                                         |
| bool             | func(name string) bool       | Returns the value of the bool flag corresponding to `name`              |
| int              | func(name string) int        | Returns the value of the int flag corresponding to `name`               |
| string           | func(name string) string     | Returns the value of the string flag corresponding to `name`            |
| string_slice     | func(name string) []string   | Returns the value of the string slice flag corresponding to `name`      |

### command

A command represents a sub-command of an app. It contains its own flags and
has an associated action. Commands may have sub-commands.

### flag

A flag is used to parse command-line flags in a cli app. Flags may be specified
on a cli app directly, as well as on commands.


---
context/examples/cli-module/command.go
---
package cli

import (
	"fmt"

	"github.com/risor-io/risor/errz"
	"github.com/risor-io/risor/object"
	"github.com/risor-io/risor/op"
	ucli "github.com/urfave/cli/v2"
)

const COMMAND object.Type = "cli.command"

type Command struct {
	value  *ucli.Command
	action *object.Function
}

func (c *Command) Type() object.Type {
	return COMMAND
}

func (c *Command) Inspect() string {
	return fmt.Sprintf("%s()", c.Type())
}

func (c *Command) Interface() interface{} {
	return c.value
}

func (c *Command) IsTruthy() bool {
	return true
}

func (c *Command) Cost() int {
	return 0
}

func (c *Command) MarshalJSON() ([]byte, error) {
	return nil, errz.TypeErrorf("type error: unable to marshal %s", COMMAND)
}

func (c *Command) RunOperation(opType op.BinaryOpType, right object.Object) object.Object {
	return object.TypeErrorf("type error: unsupported operation for %s: %v", COMMAND, opType)
}

func (c *Command) Equals(other object.Object) object.Object {
	return object.NewBool(c == other)
}

func (c *Command) SetAttr(name string, value object.Object) error {
	var errObj *object.Error
	switch name {
	case "action":
		fn, ok := value.(*object.Function)
		if !ok {
			return fmt.Errorf("expected %s, got %s", object.FUNCTION, value.Type())
		}
		c.action = fn
	case "flags":
		flagsList, ok := value.(*object.List)
		if !ok {
			return fmt.Errorf("expected %s, got %s", object.LIST, value.Type())
		}
		flags := make([]ucli.Flag, flagsList.Size())
		for i, f := range flagsList.Value() {
			flag, ok := f.(*Flag)
			if !ok {
				return fmt.Errorf("expected %s, got %s", FLAG, f.Type())
			}
			flags[i] = flag.value
		}
		c.value.Flags = flags
	case "name":
		c.value.Name, errObj = object.AsString(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "aliases":
		c.value.Aliases, errObj = object.AsStringSlice(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "usage":
		c.value.Usage, errObj = object.AsString(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "usage_text":
		c.value.UsageText, errObj = object.AsString(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "description":
		c.value.Description, errObj = object.AsString(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "args":
		c.value.Args, errObj = object.AsBool(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "args_usage":
		c.value.ArgsUsage, errObj = object.AsString(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "category":
		c.value.Category, errObj = object.AsString(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "hide_help":
		c.value.HideHelp, errObj = object.AsBool(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "hide_help_command":
		c.value.HideHelpCommand, errObj = object.AsBool(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "hidden":
		c.value.Hidden, errObj = object.AsBool(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "use_short_option_handling":
		c.value.UseShortOptionHandling, errObj = object.AsBool(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "help_name":
		c.value.HelpName, errObj = object.AsString(value)
		if errObj != nil {
			return errObj.Value()
		}
	case "custom_help_template":
		c.value.CustomHelpTemplate, errObj = object.AsString(value)
		if errObj != nil {
			return errObj.Value()
		}
	default:
		return object.TypeErrorf("type error: %s object has no attribute %q", COMMAND, name)
	}
	return nil
}

func (c *Command) GetAttr(name string) (object.Object, bool) {
	switch name {
	case "action":
		return c.action, true
	case "flags":
		l := make([]object.Object, len(c.value.Flags))
		for i, f := range c.value.Flags {
			l[i] = NewFlag(f)
		}
		return object.NewList(l), true
	case "name":
		return object.NewString(c.value.Name), true
	case "aliases":
		return object.NewStringList(c.value.Aliases), true
	case "usage":
		return object.NewString(c.value.Usage), true
	case "usage_text":
		return object.NewString(c.value.UsageText), true
	case "description":
		return object.NewString(c.value.Description), true
	case "args":
		return object.NewBool(c.value.Args), true
	case "args_usage":
		return object.NewString(c.value.ArgsUsage), true
	case "category":
		return object.NewString(c.value.Category), true
	case "hide_help":
		return object.NewBool(c.value.HideHelp), true
	case "hide_help_command":
		return object.NewBool(c.value.HideHelpCommand), true
	case "hidden":
		return object.NewBool(c.value.Hidden), true
	case "use_short_option_handling":
		return object.NewBool(c.value.UseShortOptionHandling), true
	case "help_name":
		return object.NewString(c.value.HelpName), true
	case "custom_help_template":
		return object.NewString(c.value.CustomHelpTemplate), true
	case "subcommands":
		l := make([]object.Object, len(c.value.Subcommands))
		for i, cmd := range c.value.Subcommands {
			l[i] = NewCommand(cmd)
		}
		return object.NewList(l), true
	}
	return nil, false
}

func NewCommand(c *ucli.Command) *Command {
	cmd := &Command{
		value: c,
	}
	c.Action = func(ctx *ucli.Context) error {
		if cmd.action == nil {
			return nil
		}
		callFunc, ok := object.GetCallFunc(ctx.Context)
		if !ok {
			return fmt.Errorf("no call function found")
		}
		_, err := callFunc(
			ctx.Context,
			cmd.action,
			[]object.Object{NewCtx(ctx)},
		)
		return err
	}
	return cmd
}


---
context/examples/cli-module/ctx.go
---
package cli

import (
	"context"
	"fmt"

	"github.com/risor-io/risor/arg"
	"github.com/risor-io/risor/errz"
	"github.com/risor-io/risor/object"
	"github.com/risor-io/risor/op"
	ucli "github.com/urfave/cli/v2"
)

const CTX object.Type = "cli.ctx"

type Ctx struct {
	value *ucli.Context
}

func (c *Ctx) Type() object.Type {
	return CTX
}

func (c *Ctx) Inspect() string {
	return fmt.Sprintf("%s()", c.Type())
}

func (c *Ctx) Interface() interface{} {
	return c.value
}

func (c *Ctx) IsTruthy() bool {
	return true
}

func (c *Ctx) Cost() int {
	return 0
}

func (c *Ctx) MarshalJSON() ([]byte, error) {
	return nil, errz.TypeErrorf("type error: unable to marshal %s", CTX)
}

func (c *Ctx) RunOperation(opType op.BinaryOpType, right object.Object) object.Object {
	return object.TypeErrorf("type error: unsupported operation for %s: %v", CTX, opType)
}

func (c *Ctx) Equals(other object.Object) object.Object {
	return object.NewBool(c == other)
}

func (c *Ctx) SetAttr(name string, value object.Object) error {
	return object.TypeErrorf("type error: %s object has no attribute %q", CTX, name)
}

func (c *Ctx) GetAttr(name string) (object.Object, bool) {
	switch name {
	case "args":
		return object.NewBuiltin("cli.ctx.args",
			func(ctx context.Context, args ...object.Object) object.Object {
				return object.NewStringList(c.value.Args().Slice())
			}), true
	case "narg":
		return object.NewBuiltin("cli.ctx.narg",
			func(ctx context.Context, args ...object.Object) object.Object {
				return object.NewInt(int64(c.value.NArg()))
			}), true
	case "value":
		return object.NewBuiltin("cli.ctx.value",
			func(ctx context.Context, args ...object.Object) object.Object {
				if err := arg.Require("cli.ctx.value", 1, args); err != nil {
					return err
				}
				name, err := object.AsString(args[0])
				if err != nil {
					return err
				}
				val := c.value.Value(name)
				return object.FromGoType(val)
			}), true
	case "count":
		return object.NewBuiltin("cli.ctx.count",
			func(ctx context.Context, args ...object.Object) object.Object {
				if err := arg.Require("cli.ctx.count", 1, args); err != nil {
					return err
				}
				name, err := object.AsString(args[0])
				if err != nil {
					return err
				}
				return object.NewInt(int64(c.value.Count(name)))
			}), true
	case "flag_names":
		return object.NewBuiltin("cli.ctx.flag_names",
			func(ctx context.Context, args ...object.Object) object.Object {
				return object.NewStringList(c.value.FlagNames())
			}), true
	case "local_flag_names":
		return object.NewBuiltin("cli.ctx.local_flag_names",
			func(ctx context.Context, args ...object.Object) object.Object {
				return object.NewStringList(c.value.LocalFlagNames())
			}), true
	case "is_set":
		return object.NewBuiltin("cli.ctx.is_set",
			func(ctx context.Context, args ...object.Object) object.Object {
				if err := arg.Require("cli.ctx.is_set", 1, args); err != nil {
					return err
				}
				name, err := object.AsString(args[0])
				if err != nil {
					return err
				}
				return object.NewBool(c.value.IsSet(name))
			}), true
	case "set":
		return object.NewBuiltin("cli.ctx.set",
			func(ctx context.Context, args ...object.Object) object.Object {
				if err := arg.Require("cli.ctx.set", 2, args); err != nil {
					return err
				}
				name, err := object.AsString(args[0])
				if err != nil {
					return err
				}
				value, err := object.AsString(args[1])
				if err != nil {
					return err
				}
				if err := c.value.Set(name, value); err != nil {
					return object.NewError(err)
				}
				return object.Nil
			}), true
	case "num_flags":
		return object.NewBuiltin("cli.ctx.num_flags",
			func(ctx context.Context, args ...object.Object) object.Object {
				return object.NewInt(int64(c.value.NumFlags()))
			}), true
	case "bool":
		return object.NewBuiltin("cli.ctx.bool",
			func(ctx context.Context, args ...object.Object) object.Object {
				if err := arg.Require("cli.ctx.bool", 1, args); err != nil {
					return err
				}
				name, err := object.AsString(args[0])
				if err != nil {
					return err
				}
				return object.NewBool(c.value.Bool(name))
			}), true
	case "int":
		return object.NewBuiltin("cli.ctx.int",
			func(ctx context.Context, args ...object.Object) object.Object {
				if err := arg.Require("cli.ctx.int", 1, args); err != nil {
					return err
				}
				name, err := object.AsString(args[0])
				if err != nil {
					return err
				}
				return object.NewInt(int64(c.value.Int(name)))
			}), true
	case "string":
		return object.NewBuiltin("cli.ctx.string",
			func(ctx context.Context, args ...object.Object) object.Object {
				if err := arg.Require("cli.ctx.string", 1, args); err != nil {
					return err
				}
				name, err := object.AsString(args[0])
				if err != nil {
					return err
				}
				return object.NewString(c.value.String(name))
			}), true
	case "string_slice":
		return object.NewBuiltin("cli.ctx.string_slice",
			func(ctx context.Context, args ...object.Object) object.Object {
				if err := arg.Require("cli.ctx.string_slice", 1, args); err != nil {
					return err
				}
				name, err := object.AsString(args[0])
				if err != nil {
					return err
				}
				return object.NewStringList(c.value.StringSlice(name))
			}), true
	}
	return nil, false
}

func NewCtx(c *ucli.Context) *Ctx {
	return &Ctx{value: c}
}


---
context/examples/cli-module/flag.go
---
package cli

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/risor-io/risor/errz"
	"github.com/risor-io/risor/object"
	"github.com/risor-io/risor/op"
	ucli "github.com/urfave/cli/v2"
)

const FLAG object.Type = "cli.flag"

type Flag struct {
	value ucli.Flag
}

func (f *Flag) Type() object.Type {
	return FLAG
}

func (f *Flag) Inspect() string {
	return fmt.Sprintf("%s()", f.Type())
}

func (f *Flag) Interface() interface{} {
	return f.value
}

func (f *Flag) IsTruthy() bool {
	return true
}

func (f *Flag) Cost() int {
	return 0
}

func (f *Flag) MarshalJSON() ([]byte, error) {
	return nil, errz.TypeErrorf("type error: unable to marshal %s", FLAG)
}

func (f *Flag) RunOperation(opType op.BinaryOpType, right object.Object) object.Object {
	return object.TypeErrorf("type error: unsupported operation for %s: %v", FLAG, opType)
}

func (f *Flag) Equals(other object.Object) object.Object {
	return object.NewBool(f == other)
}

func (f *Flag) SetAttr(name string, value object.Object) error {
	if err := setNamedField(f.value, name, value); err != nil {
		return err
	}
	return nil
}

func (f *Flag) GetAttr(name string) (object.Object, bool) {
	switch name {
	case "names":
		return object.NewStringList(f.value.Names()), true
	case "is_set":
		return object.NewBool(f.value.IsSet()), true
	case "string":
		return object.NewString(f.value.String()), true
	default:
		field, err := getNamedField(f.value, name)
		if err != nil {
			return nil, false
		}
		return field, true
	}
}

func NewFlag(f ucli.Flag) *Flag {
	return &Flag{value: f}
}

func getNamedField(i interface{}, name string) (object.Object, error) {
	val := reflect.ValueOf(i)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}
	if val.Kind() != reflect.Struct {
		return nil, fmt.Errorf("expected a struct, got %v", val.Kind())
	}
	name = snakeToCap(name)
	fieldVal := val.FieldByName(name)
	if !fieldVal.IsValid() {
		return nil, fmt.Errorf("no such field: %s in obj", name)
	}
	obj := object.FromGoType(fieldVal.Interface())
	if errObj, ok := obj.(*object.Error); ok {
		return nil, errObj.Value()
	}
	return obj, nil
}

func setNamedField(i interface{}, name string, value object.Object) error {
	val := reflect.ValueOf(i)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}
	if val.Kind() != reflect.Struct {
		return fmt.Errorf("expected a struct, got %v", val.Kind())
	}
	name = snakeToCap(name)
	fieldVal := val.FieldByName(name)
	if !fieldVal.IsValid() {
		return fmt.Errorf("no such field: %s in obj", name)
	}
	if !fieldVal.CanSet() {
		return fmt.Errorf("cannot set field: %s in obj", name)
	}
	if listObj, ok := value.(*object.List); ok {
		var values []string
		for _, v := range listObj.Value() {
			str, err := object.AsString(v)
			if err != nil {
				return err.Value()
			}
			values = append(values, str)
		}
		fieldVal.Set(reflect.ValueOf(values))
	} else {
		fieldVal.Set(reflect.ValueOf(value.Interface()))
	}
	return nil
}

func snakeToCap(s string) string {
	var result string
	words := strings.Split(s, "_")
	for _, word := range words {
		result += strings.Title(word)
	}
	return result
}


---
context/examples/cli-module/go.mod
---
module github.com/risor-io/risor/modules/cli

go 1.23.0

replace github.com/risor-io/risor => ../..

require (
	github.com/risor-io/risor v1.7.0
	github.com/urfave/cli/v2 v2.27.6
)

require (
	github.com/cpuguy83/go-md2man/v2 v2.0.6 // indirect
	github.com/russross/blackfriday/v2 v2.1.0 // indirect
	github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 // indirect
)


---
context/examples/cli-module/go.sum
---
github.com/cpuguy83/go-md2man/v2 v2.0.6 h1:XJtiaUW6dEEqVuZiMTn1ldk455QWwEIsMIJlo5vtkx0=
github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 h1:Jamvg5psRIccs7FGNTlIRMkT8wgtp5eCXdBlqhYGL6U=
github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/urfave/cli/v2 v2.27.6 h1:VdRdS98FNhKZ8/Az8B7MTyGQmpIr36O1EHybx/LaZ4g=
github.com/urfave/cli/v2 v2.27.6/go.mod h1:3Sevf16NykTbInEnD0yKkjDAeZDS0A6bzhBH5hrMvTQ=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 h1:gEOO8jv9F4OT7lGCjxCBTO/36wtF6j2nSip77qHd4x4=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1/go.mod h1:Ohn+xnUBiLI6FVj/9LpzZWtj1/D6lUovWYBkxHVV3aM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=


---
